---
agent: qa
created_at: 2026-01-01T19:35:37Z
depends_on:
    - T-E07-F14-006
    - T-E07-F14-007
epic: E07
feature: E07-F14
key: T-E07-F14-012
priority: 5
related-docs:
    - docs/plan/E07-enhancements/E07-F14-cascading-status-calculation/test-plan.md
    - docs/plan/E07-enhancements/E07-F14-cascading-status-calculation/acceptance-criteria.md
status: todo
task_key: T-E07-F14-024
title: Add integration tests for end-to-end cascade behavior
---

# Task: Add integration tests for end-to-end cascade behavior

## Goal

Create integration tests that verify the complete cascade flow from task changes through feature and epic status updates.

## Requirements

### Functional Requirements

- [ ] Test cascade when task status changes (start, complete, etc.)
- [ ] Test cascade when task is created
- [ ] Test cascade when task is deleted
- [ ] Test override prevents cascade update
- [ ] Test full hierarchy update (task -> feature -> epic)

### Non-Functional Requirements

- [ ] Use real database and services
- [ ] Skip in short test mode (`-short` flag)
- [ ] Clean up all test data
- [ ] Tests complete in < 5 seconds

## Implementation Plan

### Steps

1. [ ] Create calculation_integration_test.go in status package
2. [ ] Implement TestStatusCalculation_EndToEnd_Cascading
3. [ ] Implement TestStatusCalculation_Override_Prevents_Update
4. [ ] Implement TestStatusCalculation_TaskCreate_Cascades
5. [ ] Implement TestStatusCalculation_TaskDelete_Cascades

### Technical Approach

Location: `internal/status/calculation_integration_test.go`

```go
func TestStatusCalculation_EndToEnd_Cascading(t *testing.T) {
    if testing.Short() {
        t.Skip("skipping integration test")
    }

    ctx := context.Background()
    database := test.GetTestDB()
    db := repository.NewDB(database)

    // Initialize repositories and service
    epicRepo := repository.NewEpicRepository(db)
    featureRepo := repository.NewFeatureRepository(db)
    taskRepo := repository.NewTaskRepository(db)
    calcService := NewStatusCalculationService(db, epicRepo, featureRepo, taskRepo)

    // Cleanup
    defer database.ExecContext(ctx, "DELETE FROM tasks WHERE key LIKE 'T-E98-%'")
    defer database.ExecContext(ctx, "DELETE FROM features WHERE key LIKE 'E98-%'")
    defer database.ExecContext(ctx, "DELETE FROM epics WHERE key = 'E98'")

    // Create hierarchy
    epic := &models.Epic{Key: "E98", Title: "Integration Test Epic", Status: models.EpicStatusDraft, Priority: models.PriorityMedium}
    require.NoError(t, epicRepo.Create(ctx, epic))

    feature := &models.Feature{EpicID: epic.ID, Key: "E98-F01", Title: "Test Feature", Status: models.FeatureStatusDraft}
    require.NoError(t, featureRepo.Create(ctx, feature))

    tasks := []*models.Task{
        {FeatureID: feature.ID, Key: "T-E98-F01-001", Title: "Task 1", Status: models.TaskStatusTodo, Priority: 5},
        {FeatureID: feature.ID, Key: "T-E98-F01-002", Title: "Task 2", Status: models.TaskStatusTodo, Priority: 5},
        {FeatureID: feature.ID, Key: "T-E98-F01-003", Title: "Task 3", Status: models.TaskStatusTodo, Priority: 5},
    }
    for _, task := range tasks {
        require.NoError(t, taskRepo.Create(ctx, task))
    }

    t.Run("initial_state_is_draft", func(t *testing.T) {
        calcService.PropagateTaskChange(ctx, tasks[0].ID)
        f, _ := featureRepo.GetByID(ctx, feature.ID)
        assert.Equal(t, models.FeatureStatusDraft, f.Status)
    })

    t.Run("starting_task_activates_hierarchy", func(t *testing.T) {
        taskRepo.UpdateStatus(ctx, tasks[0].ID, models.TaskStatusInProgress, nil, nil)
        calcService.PropagateTaskChange(ctx, tasks[0].ID)

        f, _ := featureRepo.GetByID(ctx, feature.ID)
        assert.Equal(t, models.FeatureStatusActive, f.Status)

        e, _ := epicRepo.GetByID(ctx, epic.ID)
        assert.Equal(t, models.EpicStatusActive, e.Status)
    })

    t.Run("completing_all_tasks_completes_feature", func(t *testing.T) {
        for _, task := range tasks {
            taskRepo.UpdateStatus(ctx, task.ID, models.TaskStatusInProgress, nil, nil)
            taskRepo.UpdateStatus(ctx, task.ID, models.TaskStatusCompleted, nil, nil)
        }
        calcService.PropagateTaskChange(ctx, tasks[2].ID)

        f, _ := featureRepo.GetByID(ctx, feature.ID)
        assert.Equal(t, models.FeatureStatusCompleted, f.Status)

        e, _ := epicRepo.GetByID(ctx, epic.ID)
        assert.Equal(t, models.EpicStatusCompleted, e.Status)
    })
}

func TestStatusCalculation_Override_Prevents_Update(t *testing.T) {
    // Create feature with override=true
    // Change task status
    // Verify feature status unchanged
}
```

## Deliverables

- [ ] `internal/status/calculation_integration_test.go`
- [ ] Integration tests for all cascade scenarios

## Acceptance Criteria

- [ ] Starting task activates feature and epic
- [ ] Completing all tasks completes feature and epic
- [ ] Override prevents calculated updates
- [ ] Task creation triggers cascade
- [ ] Task deletion triggers cascade
- [ ] All tests pass with real database

## Testing Strategy

Run integration tests:

```bash
go test -v ./internal/status/... -run Integration
```

Test scenarios from test-plan.md section 4.1:

| Scenario | Expected Behavior |
|----------|-------------------|
| All tasks todo | Feature draft, Epic draft |
| One task in_progress | Feature active, Epic active |
| All tasks completed | Feature completed, Epic completed |
| Override enabled | Feature status unchanged |
| Task added to completed feature | Feature becomes active |

## Dependencies

- T-E07-F14-006: StatusCalculationService
- T-E07-F14-007: Cascade integration in commands

## Notes

- Use testing.Short() to skip in quick test runs
- Full integration test suite may take 5+ seconds
- See test-plan.md section 4 for complete integration test specs
