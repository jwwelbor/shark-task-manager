---
agent: backend
created_at: 2026-01-01T19:35:37Z
epic: E07
feature: E07-F14
key: T-E07-F14-002
priority: 9
related-docs:
    - docs/plan/E07-enhancements/E07-F14-cascading-status-calculation/status-calculation-rules.md
    - docs/plan/E07-enhancements/E07-F14-cascading-status-calculation/prd.md
    - docs/plan/E07-enhancements/E07-F14-cascading-status-calculation/test-plan.md
status: todo
task_key: T-E07-F14-014
title: Create status derivation logic in internal/status package
---

# Task: Create status derivation logic in internal/status package

## Goal

Create a new `internal/status` package containing pure functions to derive feature status from task counts and epic status from feature counts.

## Requirements

### Functional Requirements

- [ ] Create `deriveFeatureStatus(counts map[TaskStatus]int) FeatureStatus`
- [ ] Create `deriveEpicStatus(counts map[FeatureStatus]int) EpicStatus`
- [ ] Handle empty counts (no children) returning "draft"
- [ ] Handle all-completed returning "completed"
- [ ] Handle any-active returning "active"

### Non-Functional Requirements

- [ ] Pure functions with no side effects
- [ ] 100% test coverage on derivation logic
- [ ] No database dependencies (testable with mocks)

## Implementation Plan

### Steps

1. [ ] Create `internal/status/` directory
2. [ ] Create `internal/status/derivation.go` with derivation functions
3. [ ] Create `internal/status/models.go` with result types
4. [ ] Create `internal/status/derivation_test.go` with table-driven tests

### Technical Approach

File: `internal/status/derivation.go`

```go
package status

import "shark-task-manager/internal/models"

// deriveFeatureStatus calculates feature status from task status counts
func deriveFeatureStatus(counts map[models.TaskStatus]int) models.FeatureStatus {
    total := 0
    for _, c := range counts {
        total += c
    }

    if total == 0 {
        return models.FeatureStatusDraft
    }

    // Count completed (completed + archived)
    completed := counts[models.TaskStatusCompleted] + counts[models.TaskStatusArchived]
    if completed == total {
        return models.FeatureStatusCompleted
    }

    // Count active (in_progress, ready_for_review, blocked)
    active := counts[models.TaskStatusInProgress] +
              counts[models.TaskStatusReadyForReview] +
              counts[models.TaskStatusBlocked]
    if active > 0 {
        return models.FeatureStatusActive
    }

    // Check for partial completion (some completed + some todo)
    if completed > 0 && counts[models.TaskStatusTodo] > 0 {
        return models.FeatureStatusActive
    }

    // All todo
    return models.FeatureStatusDraft
}
```

## Deliverables

- [ ] `internal/status/derivation.go`
- [ ] `internal/status/models.go`
- [ ] `internal/status/derivation_test.go`

## Acceptance Criteria

- [ ] Feature status derivation matches rules in status-calculation-rules.md
- [ ] Epic status derivation matches rules in status-calculation-rules.md
- [ ] All edge cases covered (empty, all-todo, all-completed, mixed)
- [ ] Table-driven tests for all scenarios
- [ ] 100% test coverage

## Testing Strategy

Test cases from test-plan.md:

| Task Composition | Expected Status |
|------------------|-----------------|
| Empty | draft |
| All todo | draft |
| Any in_progress | active |
| Any ready_for_review | active |
| All blocked | active |
| All completed | completed |
| Mix todo + completed | active |

## Dependencies

No dependencies - pure logic functions.

## Notes

- This is the core algorithm used by the StatusCalculationService
- Keep functions pure for easy testing
- See `status-calculation-rules.md` for complete rules
- See `test-plan.md` section 2.1 for test specifications
