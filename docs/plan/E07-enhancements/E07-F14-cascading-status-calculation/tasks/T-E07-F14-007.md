---
agent: backend
created_at: 2026-01-01T19:35:37Z
depends_on:
    - T-E07-F14-006
epic: E07
feature: E07-F14
key: T-E07-F14-007
priority: 7
related-docs:
    - docs/plan/E07-enhancements/E07-F14-cascading-status-calculation/status-calculation-rules.md
    - docs/plan/E07-enhancements/E07-F14-cascading-status-calculation/prd.md
status: todo
task_key: T-E07-F14-019
title: Integrate cascade triggers into task status update methods
---

# Task: Integrate cascade triggers into task status update methods

## Goal

Modify existing task repository methods (UpdateStatus, Create, Delete) and CLI commands (start, complete, approve, block, unblock) to trigger cascading status recalculation.

## Requirements

### Functional Requirements

- [ ] Task status changes trigger `PropagateTaskChange()`
- [ ] Task creation triggers feature/epic recalculation
- [ ] Task deletion triggers feature/epic recalculation
- [ ] Cascade happens within same transaction

### Non-Functional Requirements

- [ ] No breaking changes to existing CLI behavior
- [ ] Cascade completes in < 100ms
- [ ] Errors in cascade don't prevent task updates (log warning)

## Implementation Plan

### Steps

1. [ ] Inject StatusCalculationService into task commands
2. [ ] Call PropagateTaskChange after task status updates
3. [ ] Call cascade after task creation
4. [ ] Call cascade after task deletion
5. [ ] Add integration tests for cascade behavior

### Technical Approach

Location: `internal/cli/commands/task.go`

For each status-changing command (start, complete, approve, block, unblock):

```go
// After successful task status update
if calcService != nil {
    results, err := calcService.PropagateTaskChange(ctx, task.ID)
    if err != nil {
        // Log warning but don't fail the command
        cli.Warning("Status cascade failed: %v", err)
    } else {
        for _, r := range results {
            if r.WasChanged {
                cli.Info("%s %s status: %s -> %s", r.EntityType, r.EntityKey, r.PreviousStatus, r.NewStatus)
            }
        }
    }
}
```

For task create command:

```go
// After successful task creation
if calcService != nil {
    results, _ := calcService.PropagateTaskChange(ctx, task.ID)
    // Log any status changes
}
```

For task delete command:

```go
// Capture feature/epic IDs before deletion
featureID := task.FeatureID
epicID := feature.EpicID

// Delete task
err := taskRepo.Delete(ctx, task.ID)

// Trigger cascade on parent
if calcService != nil {
    calcService.RecalculateFeatureStatus(ctx, featureID)
    calcService.RecalculateEpicStatus(ctx, epicID)
}
```

## Deliverables

- [ ] Modified task commands with cascade integration
- [ ] Integration tests verifying cascade behavior
- [ ] Updated command output showing status changes

## Acceptance Criteria

- [ ] `shark task start` updates feature/epic status
- [ ] `shark task complete` updates feature/epic status
- [ ] `shark task create` recalculates parent statuses
- [ ] CLI output shows cascade results
- [ ] Existing task command tests still pass

## Testing Strategy

Integration tests:

```go
func TestTaskStart_CascadesStatus(t *testing.T) {
    // Create feature with all todo tasks
    // Verify feature status is "draft"
    // Start one task
    // Verify feature status changed to "active"
    // Verify epic status changed to "active"
}

func TestTaskComplete_CascadesStatus(t *testing.T) {
    // Create feature with one in_progress task
    // Complete the task
    // Verify feature status changed to "completed"
}
```

## Dependencies

- T-E07-F14-006: StatusCalculationService must exist

## Notes

- Cascade is informational, not blocking - task operation succeeds even if cascade fails
- Consider making cascade optional via flag for bulk operations
- See `status-calculation-rules.md` for trigger points
