# Bug Fix Summary: T-E07-F22-030

## Quick Fix Guide for Developer

### Issue
Critical build error prevents all testing:
```
internal/db/db.go:619:12: undefined: migrateTaskNotesNoteTypeConstraint
```

### Immediate Fix Required

**Option 1: Remove the Call (Recommended if not needed)**
```bash
# Edit internal/db/db.go
# Remove lines 618-621:

# Run task_notes note_type CHECK constraint migration to include 'rejection' (E07-F22)
if err := migrateTaskNotesNoteTypeConstraint(db); err != nil {
    return fmt.Errorf("failed to migrate task_notes note_type constraint: %w", err)
}
```

**Option 2: Implement the Function (If task_notes constraint is actually needed)**
```go
// Add to internal/db/db.go or internal/db/migrate.go

func migrateTaskNotesNoteTypeConstraint(db *sql.DB) error {
    // Check if constraint exists
    // If not, recreate table with updated CHECK constraint
    // Return nil if already exists

    // Similar pattern to migrateTaskHistoryRejectionReason
    return nil
}
```

### Test the Fix
```bash
# Verify build works
make build

# Run tests
make test

# If successful, continue to add missing tests below
```

---

## Missing Test Coverage

### 1. Database Migration Tests

**File:** `internal/db/db_test.go`

Add these tests:

```go
func TestMigration_RejectionReason(t *testing.T) {
    db, cleanup := createTestDB(t)
    defer cleanup()

    err := InitDB(db)
    if err != nil {
        t.Fatalf("migration failed: %v", err)
    }

    // Verify column exists
    var columnExists int
    err = db.QueryRow(`
        SELECT COUNT(*)
        FROM pragma_table_info('task_history')
        WHERE name = 'rejection_reason'
    `).Scan(&columnExists)

    if err != nil {
        t.Fatalf("failed to check column: %v", err)
    }

    if columnExists != 1 {
        t.Error("rejection_reason column not found in task_history table")
    }

    // Verify index exists
    var indexExists int
    err = db.QueryRow(`
        SELECT COUNT(*)
        FROM sqlite_master
        WHERE type='index' AND name='idx_task_history_rejection'
    `).Scan(&indexExists)

    if err != nil {
        t.Fatalf("failed to check index: %v", err)
    }

    if indexExists != 1 {
        t.Error("idx_task_history_rejection index not found")
    }
}

func TestMigration_RejectionReason_Idempotent(t *testing.T) {
    db, cleanup := createTestDB(t)
    defer cleanup()

    // First migration
    err := InitDB(db)
    if err != nil {
        t.Fatalf("first migration failed: %v", err)
    }

    // Second migration (should not fail)
    err = InitDB(db)
    if err != nil {
        t.Fatalf("second migration failed (not idempotent): %v", err)
    }
}
```

### 2. Config IsBackwardTransition Tests

**File:** `internal/config/config_test.go`

Add this test:

```go
func TestConfig_IsBackwardTransition(t *testing.T) {
    cfg := &Config{
        StatusMetadata: map[string]StatusMetadata{
            "draft":                 {ProgressWeight: 0.10},
            "in_development":        {ProgressWeight: 0.50},
            "ready_for_code_review": {ProgressWeight: 0.85},
            "completed":             {ProgressWeight: 1.0},
        },
    }

    tests := []struct {
        name         string
        oldStatus    string
        newStatus    string
        wantBackward bool
    }{
        {"backward: review to dev", "ready_for_code_review", "in_development", true},
        {"backward: completed to review", "completed", "ready_for_code_review", true},
        {"forward: dev to review", "in_development", "ready_for_code_review", false},
        {"equal: same status", "in_development", "in_development", false},
        {"missing old status", "unknown", "in_development", false},
        {"missing new status", "in_development", "unknown", false},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := cfg.IsBackwardTransition(tt.oldStatus, tt.newStatus)
            if result != tt.wantBackward {
                t.Errorf("IsBackwardTransition(%q, %q) = %v, want %v",
                    tt.oldStatus, tt.newStatus, result, tt.wantBackward)
            }
        })
    }
}
```

### 3. Integration Tests

**File:** `test/integration/rejection_reason_test.go` (create new file)

```go
package integration

import (
    "context"
    "testing"

    "github.com/jwwelbor/shark-task-manager/internal/config"
    "github.com/jwwelbor/shark-task-manager/internal/models"
    "github.com/jwwelbor/shark-task-manager/internal/repository"
    "github.com/jwwelbor/shark-task-manager/internal/test"
)

func TestEndToEnd_RejectionReasonWorkflow(t *testing.T) {
    ctx := context.Background()
    db := test.GetTestDB()

    // Enable rejection reason requirement
    cfg := config.Get()
    originalValue := cfg.RequireRejectionReason
    cfg.RequireRejectionReason = true
    defer func() { cfg.RequireRejectionReason = originalValue }()

    // Clean up
    _, _ = db.ExecContext(ctx, "DELETE FROM tasks WHERE key LIKE 'TEST-%'")
    _, _ = db.ExecContext(ctx, "DELETE FROM features WHERE key LIKE 'TEST-%'")
    _, _ = db.ExecContext(ctx, "DELETE FROM epics WHERE key LIKE 'TEST-%'")

    // Create epic, feature, task
    epicRepo := repository.NewEpicRepository(db)
    featureRepo := repository.NewFeatureRepository(db)
    taskRepo := repository.NewTaskRepository(db)

    epic := &models.Epic{Key: "TEST-E07", Title: "Test Epic"}
    err := epicRepo.Create(ctx, epic)
    if err != nil {
        t.Fatalf("failed to create epic: %v", err)
    }
    defer db.ExecContext(ctx, "DELETE FROM epics WHERE id = ?", epic.ID)

    feature := &models.Feature{Key: "TEST-E07-F22", EpicID: epic.ID, Title: "Test Feature"}
    err = featureRepo.Create(ctx, feature)
    if err != nil {
        t.Fatalf("failed to create feature: %v", err)
    }
    defer db.ExecContext(ctx, "DELETE FROM features WHERE id = ?", feature.ID)

    task := &models.Task{
        Key:       "TEST-E07-F22-001",
        Title:     "Test Task",
        Status:    "draft",
        EpicID:    epic.ID,
        FeatureID: feature.ID,
    }
    err = taskRepo.Create(ctx, task)
    if err != nil {
        t.Fatalf("failed to create task: %v", err)
    }
    defer db.ExecContext(ctx, "DELETE FROM tasks WHERE id = ?", task.ID)

    // Forward transitions (no rejection reason needed)
    err = taskRepo.UpdateStatus(ctx, task.Key, "in_development", repository.UpdateStatusOptions{})
    if err != nil {
        t.Fatalf("forward transition to in_development failed: %v", err)
    }

    err = taskRepo.UpdateStatus(ctx, task.Key, "ready_for_code_review", repository.UpdateStatusOptions{})
    if err != nil {
        t.Fatalf("forward transition to ready_for_code_review failed: %v", err)
    }

    // Backward transition WITHOUT rejection reason (should fail)
    err = taskRepo.UpdateStatus(ctx, task.Key, "in_development", repository.UpdateStatusOptions{})
    if err == nil {
        t.Fatal("expected error for backward transition without rejection reason")
    }

    var rejErr *repository.RejectionReasonRequiredError
    if !errors.As(err, &rejErr) {
        t.Fatalf("expected RejectionReasonRequiredError, got: %T", err)
    }

    // Backward transition WITH rejection reason (should succeed)
    opts := repository.UpdateStatusOptions{
        RejectionReason: "Failed code review: missing unit tests",
    }
    err = taskRepo.UpdateStatus(ctx, task.Key, "in_development", opts)
    if err != nil {
        t.Fatalf("backward transition with rejection reason failed: %v", err)
    }

    // Verify history contains rejection reason
    historyRepo := repository.NewTaskHistoryRepository(db)
    history, err := historyRepo.GetByTaskID(ctx, task.ID)
    if err != nil {
        t.Fatalf("failed to get history: %v", err)
    }

    foundRejection := false
    for _, h := range history {
        if h.RejectionReason == "Failed code review: missing unit tests" {
            foundRejection = true
            break
        }
    }

    if !foundRejection {
        t.Error("rejection reason not found in task history")
    }
}
```

---

## Verification Steps

After implementing fixes and tests:

```bash
# 1. Verify build
make build

# 2. Run all tests
make test

# 3. Check coverage
make test-coverage
open coverage.html

# 4. Run specific test suites
go test -v ./internal/db -run TestMigration_RejectionReason
go test -v ./internal/config -run TestConfig_IsBackwardTransition
go test -v ./test/integration -run TestEndToEnd_RejectionReasonWorkflow

# 5. Verify no regressions
go test -v ./internal/repository -run TestTaskRepository_UpdateStatus
```

---

## Expected Results

After fixes:
- ✅ All tests pass
- ✅ Code coverage > 80% for rejection reason feature
- ✅ Integration test demonstrates full workflow
- ✅ Database migration tests verify schema correctness
- ✅ Config tests verify IsBackwardTransition logic

---

## Re-Submit to QA

Once all fixes are complete and tests pass:

```bash
# Move task back to ready_for_qa
./bin/shark task update T-E07-F22-030 --status ready_for_qa

# QA will re-test
```
