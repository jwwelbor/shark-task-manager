---
agent: backend
created_at: 2026-01-16T20:10:50Z
epic: E07
feature: E07-F22
key: T-E07-F22-024
priority: 1
status: todo
task_key: T-E07-F22-011
title: Add rejection_reason to task_history
---


# Task: Add rejection_reason to task_history

## Goal

Add `rejection_reason` column to the `task_history` table to store explanations for backward status transitions (e.g., code review rejection reasons).

## Database Schema Changes

### Migration Required

File: `internal/db/db.go`

Add the following migration to the auto-migration system:

```go
// Add rejection_reason column to task_history if it doesn't exist
_, err = db.ExecContext(ctx, `
    ALTER TABLE task_history ADD COLUMN rejection_reason TEXT
`)
if err != nil && !strings.Contains(err.Error(), "duplicate column name") {
    return fmt.Errorf("failed to add rejection_reason column: %w", err)
}

// Create index for querying tasks with rejections
_, err = db.ExecContext(ctx, `
    CREATE INDEX IF NOT EXISTS idx_task_history_rejection ON task_history(rejection_reason)
`)
if err != nil {
    return fmt.Errorf("failed to create rejection_reason index: %w", err)
}
```

### Table Schema (After Migration)

```sql
CREATE TABLE task_history (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    task_id INTEGER NOT NULL,
    from_status TEXT NOT NULL,
    to_status TEXT NOT NULL,
    rejection_reason TEXT,        -- NEW COLUMN
    notes TEXT,
    agent TEXT,
    changed_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (task_id) REFERENCES tasks(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_task_history_rejection ON task_history(rejection_reason);
```

## Data Model Updates

### Update TaskHistory Model

File: `internal/models/task_history.go`

Add `RejectionReason` field to the TaskHistory struct:

```go
type TaskHistory struct {
    ID              int64     `json:"id"`
    TaskID          int64     `json:"task_id"`
    FromStatus      string    `json:"from_status"`
    ToStatus        string    `json:"to_status"`
    RejectionReason string    `json:"rejection_reason,omitempty"` // NEW FIELD
    Notes           string    `json:"notes,omitempty"`
    Agent           string    `json:"agent,omitempty"`
    ChangedAt       time.Time `json:"changed_at"`
}
```

### Repository Method Updates

File: `internal/repository/task_history_repository.go`

Update the `Create` method to accept and store rejection reason:

```go
func (r *TaskHistoryRepository) Create(ctx context.Context, history *models.TaskHistory) error {
    query := `
        INSERT INTO task_history (
            task_id, from_status, to_status, rejection_reason, notes, agent, changed_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?)
    `

    result, err := r.db.ExecContext(ctx, query,
        history.TaskID,
        history.FromStatus,
        history.ToStatus,
        history.RejectionReason, // NEW PARAMETER
        history.Notes,
        history.Agent,
        history.ChangedAt,
    )

    if err != nil {
        return fmt.Errorf("failed to create task history: %w", err)
    }

    id, _ := result.LastInsertId()
    history.ID = id

    return nil
}
```

Update query methods to include rejection_reason:

```go
func (r *TaskHistoryRepository) GetByTaskID(ctx context.Context, taskID int64) ([]*models.TaskHistory, error) {
    query := `
        SELECT id, task_id, from_status, to_status, rejection_reason, notes, agent, changed_at
        FROM task_history
        WHERE task_id = ?
        ORDER BY changed_at DESC
    `

    rows, err := r.db.QueryContext(ctx, query, taskID)
    if err != nil {
        return nil, fmt.Errorf("failed to query task history: %w", err)
    }
    defer rows.Close()

    var histories []*models.TaskHistory
    for rows.Next() {
        h := &models.TaskHistory{}
        err := rows.Scan(
            &h.ID,
            &h.TaskID,
            &h.FromStatus,
            &h.ToStatus,
            &h.RejectionReason, // NEW FIELD
            &h.Notes,
            &h.Agent,
            &h.ChangedAt,
        )
        if err != nil {
            return nil, fmt.Errorf("failed to scan task history: %w", err)
        }
        histories = append(histories, h)
    }

    return histories, nil
}
```

## Implementation Steps

1. Add migration code to `internal/db/db.go` in the `InitDB()` function
2. Add `RejectionReason` field to `models.TaskHistory` struct
3. Update `TaskHistoryRepository.Create()` to accept rejection reason
4. Update all query methods to include rejection_reason in SELECT statements
5. Update all Scan() calls to include rejection_reason field
6. Test migration on fresh database
7. Test migration on existing database (should not fail)

## Acceptance Criteria

- [ ] Migration runs successfully on fresh database
- [ ] Migration runs successfully on existing database (idempotent)
- [ ] `rejection_reason` column exists in `task_history` table
- [ ] Index `idx_task_history_rejection` exists on `rejection_reason` column
- [ ] TaskHistory struct includes `RejectionReason` field
- [ ] Create() method accepts and stores rejection reason
- [ ] GetByTaskID() returns rejection reason
- [ ] NULL rejection reasons are handled gracefully (empty string in JSON)

## Testing Requirements

### Database Migration Tests

File: `internal/db/db_test.go`

```go
func TestMigration_RejectionReason(t *testing.T) {
    // Create temp database
    db, cleanup := createTestDB(t)
    defer cleanup()

    // Run migration
    err := InitDB(db)
    if err != nil {
        t.Fatalf("migration failed: %v", err)
    }

    // Verify column exists
    var columnExists int
    err = db.QueryRow(`
        SELECT COUNT(*)
        FROM pragma_table_info('task_history')
        WHERE name = 'rejection_reason'
    `).Scan(&columnExists)

    if err != nil {
        t.Fatalf("failed to check column: %v", err)
    }

    if columnExists != 1 {
        t.Error("rejection_reason column not found")
    }

    // Verify index exists
    var indexExists int
    err = db.QueryRow(`
        SELECT COUNT(*)
        FROM sqlite_master
        WHERE type='index' AND name='idx_task_history_rejection'
    `).Scan(&indexExists)

    if err != nil {
        t.Fatalf("failed to check index: %v", err)
    }

    if indexExists != 1 {
        t.Error("idx_task_history_rejection index not found")
    }
}

func TestMigration_RejectionReason_Idempotent(t *testing.T) {
    // Create database and run migration twice
    db, cleanup := createTestDB(t)
    defer cleanup()

    // First migration
    err := InitDB(db)
    if err != nil {
        t.Fatalf("first migration failed: %v", err)
    }

    // Second migration (should not fail)
    err = InitDB(db)
    if err != nil {
        t.Fatalf("second migration failed: %v", err)
    }
}
```

### Repository Tests

File: `internal/repository/task_history_repository_test.go`

```go
func TestTaskHistoryRepository_CreateWithRejectionReason(t *testing.T) {
    ctx := context.Background()
    db := test.GetTestDB()
    repo := NewTaskHistoryRepository(db)

    // Create test task
    taskID := createTestTask(t, db)

    // Create history with rejection reason
    history := &models.TaskHistory{
        TaskID:          taskID,
        FromStatus:      "ready_for_code_review",
        ToStatus:        "in_development",
        RejectionReason: "Missing error handling for edge cases",
        ChangedAt:       time.Now(),
    }

    err := repo.Create(ctx, history)
    if err != nil {
        t.Fatalf("Create() failed: %v", err)
    }

    if history.ID == 0 {
        t.Error("expected ID to be set")
    }

    // Retrieve and verify
    retrieved, err := repo.GetByTaskID(ctx, taskID)
    if err != nil {
        t.Fatalf("GetByTaskID() failed: %v", err)
    }

    if len(retrieved) != 1 {
        t.Fatalf("expected 1 history entry, got %d", len(retrieved))
    }

    if retrieved[0].RejectionReason != "Missing error handling for edge cases" {
        t.Errorf("expected rejection reason to be stored, got: %s", retrieved[0].RejectionReason)
    }
}

func TestTaskHistoryRepository_CreateWithoutRejectionReason(t *testing.T) {
    ctx := context.Background()
    db := test.GetTestDB()
    repo := NewTaskHistoryRepository(db)

    taskID := createTestTask(t, db)

    // Create history WITHOUT rejection reason
    history := &models.TaskHistory{
        TaskID:     taskID,
        FromStatus: "in_development",
        ToStatus:   "ready_for_code_review",
        ChangedAt:  time.Now(),
    }

    err := repo.Create(ctx, history)
    if err != nil {
        t.Fatalf("Create() failed: %v", err)
    }

    // Retrieve and verify
    retrieved, err := repo.GetByTaskID(ctx, taskID)
    if err != nil {
        t.Fatalf("GetByTaskID() failed: %v", err)
    }

    if len(retrieved) != 1 {
        t.Fatalf("expected 1 history entry, got %d", len(retrieved))
    }

    // Should be empty string, not cause error
    if retrieved[0].RejectionReason != "" {
        t.Errorf("expected empty rejection reason, got: %s", retrieved[0].RejectionReason)
    }
}
```

## Notes

- Migration must be idempotent (safe to run multiple times)
- Existing task_history records will have NULL rejection_reason (displays as empty string in Go)
- Index improves query performance for filtering by rejection status
- JSON serialization uses `omitempty` to exclude empty rejection reasons from output
