
---
key: T-E07-F22-025
title: Implement IsBackwardTransition in config
epic: E07
feature: E07-F22
agent: backend
status: todo
priority: 2
created_at: 2026-01-16T20:10:50Z
---

# Task: Implement IsBackwardTransition in config

## Goal

Implement `IsBackwardTransition()` method in the config package to automatically detect backward status transitions by comparing `progress_weight` values from E07-F14.

**Key Innovation:** Config-driven detection eliminates hardcoded status lists. Any transition where new status has lower progress_weight than old status is considered backward.

## Implementation Details

### Add IsBackwardTransition Method

File: `internal/config/config.go`

Add the following method to the `Config` struct:

```go
// IsBackwardTransition checks if transitioning from oldStatus to newStatus
// represents backward progress (decreasing progress_weight).
//
// Returns true if:
// - Both statuses have valid metadata
// - newStatus.ProgressWeight < oldStatus.ProgressWeight
//
// Returns false if:
// - Either status has no metadata
// - Progress weight is equal or increases
func (c *Config) IsBackwardTransition(oldStatus, newStatus string) bool {
    oldMeta := c.GetStatusMetadata(oldStatus)
    newMeta := c.GetStatusMetadata(newStatus)

    // If either status has no metadata, can't determine direction
    if oldMeta == nil || newMeta == nil {
        return false
    }

    // Backward if new progress is less than old progress
    return newMeta.ProgressWeight < oldMeta.ProgressWeight
}
```

### Helper Method: GetStatusMetadata

If not already present, add helper method:

```go
// GetStatusMetadata returns the metadata for a given status.
// Returns nil if status not found in configuration.
func (c *Config) GetStatusMetadata(status string) *StatusMetadata {
    if c.StatusMetadata == nil {
        return nil
    }

    meta, exists := c.StatusMetadata[status]
    if !exists {
        return nil
    }

    return &meta
}
```

### Example Usage

```go
cfg := config.Get()

// Example 1: Backward transition (code review → development)
isBackward := cfg.IsBackwardTransition("ready_for_code_review", "in_development")
// Returns: true (0.85 → 0.50 is backward)

// Example 2: Forward transition (development → code review)
isBackward = cfg.IsBackwardTransition("in_development", "ready_for_code_review")
// Returns: false (0.50 → 0.85 is forward)

// Example 3: Same progress level
isBackward = cfg.IsBackwardTransition("in_development", "in_development")
// Returns: false (0.50 → 0.50 is no change)

// Example 4: Unknown status
isBackward = cfg.IsBackwardTransition("unknown_status", "in_development")
// Returns: false (can't determine, safer to not require rejection reason)
```

## Configuration Example

The method uses `progress_weight` from E07-F14 config:

```json
{
  "status_metadata": {
    "draft": {
      "progress_weight": 0.10
    },
    "ready_for_refinement": {
      "progress_weight": 0.20
    },
    "in_refinement": {
      "progress_weight": 0.25
    },
    "ready_for_development": {
      "progress_weight": 0.30
    },
    "in_development": {
      "progress_weight": 0.50
    },
    "ready_for_code_review": {
      "progress_weight": 0.85
    },
    "in_code_review": {
      "progress_weight": 0.87
    },
    "ready_for_qa": {
      "progress_weight": 0.90
    },
    "in_qa": {
      "progress_weight": 0.92
    },
    "ready_for_approval": {
      "progress_weight": 0.95
    },
    "in_approval": {
      "progress_weight": 0.97
    },
    "completed": {
      "progress_weight": 1.0
    }
  }
}
```

## Edge Cases

### Case 1: Missing Status Metadata

```go
// If "custom_status" not in config
isBackward := cfg.IsBackwardTransition("ready_for_code_review", "custom_status")
// Returns: false (can't determine, default to safe behavior)
```

**Behavior:** Return `false` to avoid blocking legitimate transitions when status metadata is incomplete.

### Case 2: Equal Progress Weight

```go
// If two statuses have same progress weight
isBackward := cfg.IsBackwardTransition("status_a", "status_b")
// Both have progress_weight: 0.50
// Returns: false (not backward, no decrease)
```

**Behavior:** Equal progress is NOT backward (rejection reason not required).

### Case 3: Nil Config

```go
var cfg *Config
isBackward := cfg.IsBackwardTransition("status_a", "status_b")
// Returns: false (nil check in GetStatusMetadata)
```

**Behavior:** Method should be nil-safe.

## Implementation Steps

1. Verify `StatusMetadata` struct includes `ProgressWeight float64` field (from E07-F14)
2. Add `GetStatusMetadata()` helper method (if not exists)
3. Implement `IsBackwardTransition()` method
4. Add nil checks for safety
5. Write comprehensive unit tests
6. Test with real config examples

## Acceptance Criteria

- [ ] `IsBackwardTransition()` method exists in `Config` struct
- [ ] Method correctly identifies backward transitions (decreasing progress_weight)
- [ ] Method correctly identifies forward transitions (increasing progress_weight)
- [ ] Method returns `false` for equal progress_weight
- [ ] Method returns `false` for missing status metadata (safe default)
- [ ] Method is nil-safe (doesn't panic on nil config)
- [ ] `GetStatusMetadata()` helper method exists
- [ ] Helper returns nil for missing statuses

## Testing Requirements

### Unit Tests

File: `internal/config/config_test.go`

```go
func TestConfig_IsBackwardTransition(t *testing.T) {
    cfg := &Config{
        StatusMetadata: map[string]StatusMetadata{
            "draft":                 {ProgressWeight: 0.10},
            "in_development":        {ProgressWeight: 0.50},
            "ready_for_code_review": {ProgressWeight: 0.85},
            "in_code_review":        {ProgressWeight: 0.87},
            "completed":             {ProgressWeight: 1.0},
        },
    }

    tests := []struct {
        name       string
        oldStatus  string
        newStatus  string
        wantBackward bool
    }{
        {
            name:       "backward: review to development",
            oldStatus:  "ready_for_code_review",
            newStatus:  "in_development",
            wantBackward: true,
        },
        {
            name:       "backward: completed to review",
            oldStatus:  "completed",
            newStatus:  "ready_for_code_review",
            wantBackward: true,
        },
        {
            name:       "forward: development to review",
            oldStatus:  "in_development",
            newStatus:  "ready_for_code_review",
            wantBackward: false,
        },
        {
            name:       "forward: draft to development",
            oldStatus:  "draft",
            newStatus:  "in_development",
            wantBackward: false,
        },
        {
            name:       "equal: same status",
            oldStatus:  "in_development",
            newStatus:  "in_development",
            wantBackward: false,
        },
        {
            name:       "missing old status",
            oldStatus:  "unknown_status",
            newStatus:  "in_development",
            wantBackward: false,
        },
        {
            name:       "missing new status",
            oldStatus:  "in_development",
            newStatus:  "unknown_status",
            wantBackward: false,
        },
        {
            name:       "both missing",
            oldStatus:  "unknown_a",
            newStatus:  "unknown_b",
            wantBackward: false,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := cfg.IsBackwardTransition(tt.oldStatus, tt.newStatus)
            if result != tt.wantBackward {
                t.Errorf("IsBackwardTransition(%q, %q) = %v, want %v",
                    tt.oldStatus, tt.newStatus, result, tt.wantBackward)
            }
        })
    }
}

func TestConfig_IsBackwardTransition_NilConfig(t *testing.T) {
    var cfg *Config

    // Should not panic
    result := cfg.IsBackwardTransition("status_a", "status_b")

    if result != false {
        t.Error("expected false for nil config")
    }
}

func TestConfig_IsBackwardTransition_EmptyMetadata(t *testing.T) {
    cfg := &Config{
        StatusMetadata: map[string]StatusMetadata{},
    }

    result := cfg.IsBackwardTransition("status_a", "status_b")

    if result != false {
        t.Error("expected false for empty metadata")
    }
}

func TestConfig_GetStatusMetadata(t *testing.T) {
    cfg := &Config{
        StatusMetadata: map[string]StatusMetadata{
            "in_development": {ProgressWeight: 0.50},
        },
    }

    // Test existing status
    meta := cfg.GetStatusMetadata("in_development")
    if meta == nil {
        t.Fatal("expected metadata, got nil")
    }
    if meta.ProgressWeight != 0.50 {
        t.Errorf("expected progress_weight 0.50, got %v", meta.ProgressWeight)
    }

    // Test missing status
    meta = cfg.GetStatusMetadata("unknown")
    if meta != nil {
        t.Error("expected nil for unknown status")
    }

    // Test nil config
    var nilCfg *Config
    meta = nilCfg.GetStatusMetadata("status")
    if meta != nil {
        t.Error("expected nil for nil config")
    }
}
```

### Integration Tests with Real Config

File: `internal/config/config_integration_test.go`

```go
func TestIsBackwardTransition_WithRealConfig(t *testing.T) {
    // Load actual .sharkconfig.json
    cfg, err := LoadConfig(".sharkconfig.json")
    if err != nil {
        t.Fatalf("failed to load config: %v", err)
    }

    // Test common backward transitions
    backwardCases := []struct {
        from string
        to   string
    }{
        {"ready_for_code_review", "in_development"},
        {"in_code_review", "in_development"},
        {"ready_for_qa", "in_development"},
        {"in_approval", "ready_for_qa"},
        {"completed", "in_development"},
    }

    for _, tc := range backwardCases {
        t.Run(fmt.Sprintf("%s_to_%s", tc.from, tc.to), func(t *testing.T) {
            if !cfg.IsBackwardTransition(tc.from, tc.to) {
                t.Errorf("expected %s → %s to be backward transition", tc.from, tc.to)
            }
        })
    }

    // Test common forward transitions
    forwardCases := []struct {
        from string
        to   string
    }{
        {"draft", "ready_for_refinement"},
        {"in_development", "ready_for_code_review"},
        {"ready_for_code_review", "in_code_review"},
        {"in_qa", "ready_for_approval"},
        {"ready_for_approval", "completed"},
    }

    for _, tc := range forwardCases {
        t.Run(fmt.Sprintf("%s_to_%s", tc.from, tc.to), func(t *testing.T) {
            if cfg.IsBackwardTransition(tc.from, tc.to) {
                t.Errorf("expected %s → %s to be forward transition", tc.from, tc.to)
            }
        })
    }
}
```

## Notes

- Method relies on E07-F14's `progress_weight` field in `StatusMetadata`
- Returns `false` for unknown statuses (safer default - don't block transitions)
- Method is pure function (no side effects, no state modification)
- Nil-safe implementation prevents panics
- Works with any workflow defined in config (no hardcoded status names)
