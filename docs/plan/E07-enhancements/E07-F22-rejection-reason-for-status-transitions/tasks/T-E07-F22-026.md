---
key: T-E07-F22-026

title: Add rejection reason validation to UpdateStatus
epic: E07
feature: E07-F22
agent: backend
status: ready_for_code_review
priority: 3
dependencies: [T-E07-F22-024, T-E07-F22-025]
created_at: 2026-01-16T20:10:51Z
---

# Task: Add rejection reason validation to UpdateStatus

## Goal

Add validation to the `UpdateStatus` repository method to enforce that rejection reasons are provided when a task undergoes a backward transition (moving back to earlier phases in the workflow), enabling the feature requirement to require reasons for task rejections.

## Success Criteria

- [x] Backward transitions require a non-empty reason (rejection reason)
- [x] Forward transitions do not require a reason
- [x] Empty or whitespace-only reasons are rejected for backward transitions
- [x] --force flag bypasses reason requirement
- [x] Error messages clearly indicate the reason requirement
- [x] All comprehensive tests passing

## Implementation Guidance

### Overview

When a task is rejected and sent backward in the workflow (e.g., from `ready_for_code_review` to `in_progress`), we need to capture WHY it was rejected. The UpdateStatus method in TaskRepository needs to validate:

1. Detect if the transition is backward (using IsBackwardTransition from workflow config)
2. For backward transitions, require a non-empty reason in the `notes` parameter
3. Allow the --force flag to bypass this requirement
4. Forward transitions should not require a reason

### Key Implementation Details

**Backward Transition Detection**:
- Use `workflow.IsBackwardTransition(currentStatus, newStatus)` to determine direction
- Workflow config contains status phases (planning, development, review, qa, approval, done)
- Lower phase order = earlier in workflow; higher order = later in workflow

**Validation Logic**:
```go
if isBackward {
    // Backward transitions require a non-empty reason
    if notes == nil || strings.TrimSpace(*notes) == "" {
        return fmt.Errorf("rejection reason required for backward transition from %s to %s: use --reason flag or use --force to bypass", currentStatus, newStatus)
    }
}
```

## Implementation Steps

1. Update `UpdateStatusOptions` struct to include `RejectionReason`
2. Modify `UpdateStatus()` to check for backward transitions
3. Add rejection reason validation logic
4. Create `RejectionReasonRequiredError` type
5. Update history recording to include rejection reason
6. Ensure transaction atomicity
7. Write comprehensive tests

## Acceptance Criteria

- [ ] `UpdateStatusOptions` struct includes `RejectionReason` field
- [ ] `UpdateStatus()` checks `cfg.RequireRejectionReason`
- [ ] `UpdateStatus()` uses `cfg.IsBackwardTransition()` to detect backward moves
- [ ] Returns `RejectionReasonRequiredError` when rejection reason missing
- [ ] Error includes task key, from/to status, and progress percentages
- [ ] Rejection reason stored in task_history when provided
- [ ] Empty/whitespace rejection reasons rejected (use `strings.TrimSpace`)
- [ ] Forward transitions work without rejection reason
- [ ] Transaction rolls back on error

## Testing Requirements

### Unit Tests

File: `internal/repository/task_repository_test.go`

```go
func TestTaskRepository_UpdateStatus_RequiresRejectionReason(t *testing.T) {
    ctx := context.Background()
    db := test.GetTestDB()
    repo := NewTaskRepository(db)

    // Clean up
    _, _ = db.ExecContext(ctx, "DELETE FROM tasks WHERE key LIKE 'TEST-%'")

    // Seed test data
    epicID, featureID := test.SeedTestData()

    // Create task in ready_for_code_review status
    task := &models.Task{
        Key:       "TEST-E07-F22-001",
        Title:     "Test Task",
        Status:    "ready_for_code_review",
        EpicID:    epicID,
        FeatureID: featureID,
    }

    err := repo.Create(ctx, task)
    if err != nil {
        t.Fatalf("Create() failed: %v", err)
    }
    defer db.ExecContext(ctx, "DELETE FROM tasks WHERE id = ?", task.ID)

    // Set config to require rejection reason
    cfg := config.Get()
    originalValue := cfg.RequireRejectionReason
    cfg.RequireRejectionReason = true
    defer func() { cfg.RequireRejectionReason = originalValue }()

    // Attempt backward transition WITHOUT rejection reason
    opts := UpdateStatusOptions{} // Empty rejection reason
    err = repo.UpdateStatus(ctx, task.Key, "in_development", opts)

    // Should fail with RejectionReasonRequiredError
    if err == nil {
        t.Fatal("expected error when rejection reason missing")
    }

    var rejErr *RejectionReasonRequiredError
    if !errors.As(err, &rejErr) {
        t.Fatalf("expected RejectionReasonRequiredError, got: %T", err)
    }

    // Verify error details
    if rejErr.TaskKey != task.Key {
        t.Errorf("expected task_key %s, got %s", task.Key, rejErr.TaskKey)
    }
    if rejErr.FromStatus != "ready_for_code_review" {
        t.Errorf("expected from_status ready_for_code_review, got %s", rejErr.FromStatus)
    }
    if rejErr.ToStatus != "in_development" {
        t.Errorf("expected to_status in_development, got %s", rejErr.ToStatus)
    }

    // Verify task status NOT changed
    updated, err := repo.GetByKey(ctx, task.Key)
    if err != nil {
        t.Fatalf("GetByKey() failed: %v", err)
    }
    if updated.Status != "ready_for_code_review" {
        t.Errorf("task status should not change on error, got: %s", updated.Status)
    }
}

func TestTaskRepository_UpdateStatus_WithRejectionReason(t *testing.T) {
    ctx := context.Background()
    db := test.GetTestDB()
    repo := NewTaskRepository(db)

    // Clean up
    _, _ = db.ExecContext(ctx, "DELETE FROM tasks WHERE key LIKE 'TEST-%'")

    // Seed and create task
    epicID, featureID := test.SeedTestData()
    task := &models.Task{
        Key:       "TEST-E07-F22-002",
        Title:     "Test Task",
        Status:    "ready_for_code_review",
        EpicID:    epicID,
        FeatureID: featureID,
    }
    err := repo.Create(ctx, task)
    if err != nil {
        t.Fatalf("Create() failed: %v", err)
    }
    defer db.ExecContext(ctx, "DELETE FROM tasks WHERE id = ?", task.ID)

    // Enable rejection reason requirement
    cfg := config.Get()
    originalValue := cfg.RequireRejectionReason
    cfg.RequireRejectionReason = true
    defer func() { cfg.RequireRejectionReason = originalValue }()

    // Backward transition WITH rejection reason
    opts := UpdateStatusOptions{
        RejectionReason: "Missing error handling for edge cases",
        Agent:           "test-agent",
    }
    err = repo.UpdateStatus(ctx, task.Key, "in_development", opts)
    if err != nil {
        t.Fatalf("UpdateStatus() failed: %v", err)
    }

    // Verify task status updated
    updated, err := repo.GetByKey(ctx, task.Key)
    if err != nil {
        t.Fatalf("GetByKey() failed: %v", err)
    }
    if updated.Status != "in_development" {
        t.Errorf("expected status in_development, got: %s", updated.Status)
    }

    // Verify history recorded with rejection reason
    historyRepo := NewTaskHistoryRepository(db)
    history, err := historyRepo.GetByTaskID(ctx, task.ID)
    if err != nil {
        t.Fatalf("GetByTaskID() failed: %v", err)
    }

    if len(history) == 0 {
        t.Fatal("expected history entry")
    }

    lastEntry := history[0] // Most recent first
    if lastEntry.RejectionReason != "Missing error handling for edge cases" {
        t.Errorf("expected rejection reason in history, got: %s", lastEntry.RejectionReason)
    }
    if lastEntry.Agent != "test-agent" {
        t.Errorf("expected agent test-agent, got: %s", lastEntry.Agent)
    }
}

func TestTaskRepository_UpdateStatus_ForwardTransition_NoRejectionNeeded(t *testing.T) {
    ctx := context.Background()
    db := test.GetTestDB()
    repo := NewTaskRepository(db)

    // Clean up
    _, _ = db.ExecContext(ctx, "DELETE FROM tasks WHERE key LIKE 'TEST-%'")

    // Seed and create task
    epicID, featureID := test.SeedTestData()
    task := &models.Task{
        Key:       "TEST-E07-F22-003",
        Title:     "Test Task",
        Status:    "in_development",
        EpicID:    epicID,
        FeatureID: featureID,
    }
    err := repo.Create(ctx, task)
    if err != nil {
        t.Fatalf("Create() failed: %v", err)
    }
    defer db.ExecContext(ctx, "DELETE FROM tasks WHERE id = ?", task.ID)

    // Enable rejection reason requirement
    cfg := config.Get()
    cfg.RequireRejectionReason = true

    // Forward transition WITHOUT rejection reason (should succeed)
    opts := UpdateStatusOptions{} // No rejection reason
    err = repo.UpdateStatus(ctx, task.Key, "ready_for_code_review", opts)
    if err != nil {
        t.Fatalf("UpdateStatus() should succeed for forward transitions: %v", err)
    }

    // Verify status updated
    updated, err := repo.GetByKey(ctx, task.Key)
    if err != nil {
        t.Fatalf("GetByKey() failed: %v", err)
    }
    if updated.Status != "ready_for_code_review" {
        t.Errorf("expected status ready_for_code_review, got: %s", updated.Status)
    }
}

func TestTaskRepository_UpdateStatus_WhitespaceRejectionReason(t *testing.T) {
    ctx := context.Background()
    db := test.GetTestDB()
    repo := NewTaskRepository(db)

    // Clean up
    _, _ = db.ExecContext(ctx, "DELETE FROM tasks WHERE key LIKE 'TEST-%'")

    // Seed and create task
    epicID, featureID := test.SeedTestData()
    task := &models.Task{
        Key:       "TEST-E07-F22-004",
        Title:     "Test Task",
        Status:    "ready_for_code_review",
        EpicID:    epicID,
        FeatureID: featureID,
    }
    err := repo.Create(ctx, task)
    if err != nil {
        t.Fatalf("Create() failed: %v", err)
    }
    defer db.ExecContext(ctx, "DELETE FROM tasks WHERE id = ?", task.ID)

    // Enable rejection reason requirement
    cfg := config.Get()
    cfg.RequireRejectionReason = true

    // Backward transition with whitespace-only rejection reason
    opts := UpdateStatusOptions{
        RejectionReason: "   ", // Whitespace only
    }
    err = repo.UpdateStatus(ctx, task.Key, "in_development", opts)

    // Should fail (whitespace not valid)
    if err == nil {
        t.Fatal("expected error for whitespace-only rejection reason")
    }

    var rejErr *RejectionReasonRequiredError
    if !errors.As(err, &rejErr) {
        t.Errorf("expected RejectionReasonRequiredError, got: %T", err)
    }
}
```

## Notes

- **Transaction Safety:** Entire update (status + history) in single transaction
- **Whitespace Handling:** Use `strings.TrimSpace()` to reject empty/whitespace reasons
- **Config-Driven:** Behavior controlled by `require_rejection_reason` config option
- **Backward Detection:** Uses `cfg.IsBackwardTransition()` from T-E07-F22-025
- **Error Details:** Include progress percentages for user-friendly error messages

## Related Feature Requirements

- [Feature PRD - REQ-F-002: Rejection Reason Requirement](../feature.md#requirements)
- [Feature PRD - Story 1: Code Review Rejection](../feature.md#user-stories)
