
---
key: T-E07-F22-026
title: Add rejection reason validation to UpdateStatus
epic: E07
feature: E07-F22
agent: backend
status: todo
priority: 3
dependencies: [T-E07-F22-024, T-E07-F22-025]
created_at: 2026-01-16T20:10:50Z
---

# Task: Add rejection reason validation to UpdateStatus

## Goal

Add rejection reason validation logic to `TaskRepository.UpdateStatus()` method. Requires rejection reason when:
1. Config has `require_rejection_reason: true`
2. Status transition is backward (detected via `IsBackwardTransition()`)

## Implementation Details

### Update UpdateStatus Signature

File: `internal/repository/task_repository.go`

```go
type UpdateStatusOptions struct {
    RejectionReason string
    Notes           string
    Agent           string
}

// UpdateStatus updates task status with validation for backward transitions
func (r *TaskRepository) UpdateStatus(
    ctx context.Context,
    taskKey string,
    newStatus string,
    opts UpdateStatusOptions,
) error {
    // Get current task
    task, err := r.GetByKey(ctx, taskKey)
    if err != nil {
        return fmt.Errorf("failed to get task: %w", err)
    }

    // Get config
    cfg := config.Get()

    // Check if rejection reason required
    if cfg.RequireRejectionReason && cfg.IsBackwardTransition(task.Status, newStatus) {
        if strings.TrimSpace(opts.RejectionReason) == "" {
            oldMeta := cfg.GetStatusMetadata(task.Status)
            newMeta := cfg.GetStatusMetadata(newStatus)

            return &RejectionReasonRequiredError{
                TaskKey:      task.Key,
                FromStatus:   task.Status,
                ToStatus:     newStatus,
                FromProgress: oldMeta.ProgressWeight * 100,
                ToProgress:   newMeta.ProgressWeight * 100,
            }
        }
    }

    // Validate new status is allowed
    if !cfg.IsValidTransition(task.Status, newStatus) {
        return &InvalidTransitionError{
            TaskKey:    task.Key,
            FromStatus: task.Status,
            ToStatus:   newStatus,
        }
    }

    // Begin transaction
    tx, err := r.db.BeginTx(ctx, nil)
    if err != nil {
        return fmt.Errorf("failed to begin transaction: %w", err)
    }
    defer tx.Rollback()

    // Update task status
    query := `
        UPDATE tasks
        SET status = ?, updated_at = CURRENT_TIMESTAMP
        WHERE key = ?
    `
    _, err = tx.ExecContext(ctx, query, newStatus, taskKey)
    if err != nil {
        return fmt.Errorf("failed to update task status: %w", err)
    }

    // Record history
    historyQuery := `
        INSERT INTO task_history (
            task_id, from_status, to_status, rejection_reason, notes, agent, changed_at
        ) VALUES (?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
    `
    _, err = tx.ExecContext(ctx, historyQuery,
        task.ID,
        task.Status,
        newStatus,
        opts.RejectionReason,
        opts.Notes,
        opts.Agent,
    )
    if err != nil {
        return fmt.Errorf("failed to record task history: %w", err)
    }

    // Commit transaction
    if err := tx.Commit(); err != nil {
        return fmt.Errorf("failed to commit transaction: %w", err)
    }

    return nil
}
```

### Add Custom Error Type

File: `internal/repository/errors.go`

```go
// RejectionReasonRequiredError is returned when a backward transition
// is attempted without providing a rejection reason.
type RejectionReasonRequiredError struct {
    TaskKey      string
    FromStatus   string
    ToStatus     string
    FromProgress float64
    ToProgress   float64
}

func (e *RejectionReasonRequiredError) Error() string {
    return fmt.Sprintf(
        "rejection reason required: transitioning %s from %s (%.0f%%) to %s (%.0f%%) decreases progress",
        e.TaskKey,
        e.FromStatus,
        e.FromProgress,
        e.ToStatus,
        e.ToProgress,
    )
}

// IsRejectionReasonRequired returns true if the error is a RejectionReasonRequiredError
func IsRejectionReasonRequired(err error) bool {
    var rejErr *RejectionReasonRequiredError
    return errors.As(err, &rejErr)
}
```

## Implementation Steps

1. Update `UpdateStatusOptions` struct to include `RejectionReason`
2. Modify `UpdateStatus()` to check for backward transitions
3. Add rejection reason validation logic
4. Create `RejectionReasonRequiredError` type
5. Update history recording to include rejection reason
6. Ensure transaction atomicity
7. Write comprehensive tests

## Acceptance Criteria

- [ ] `UpdateStatusOptions` struct includes `RejectionReason` field
- [ ] `UpdateStatus()` checks `cfg.RequireRejectionReason`
- [ ] `UpdateStatus()` uses `cfg.IsBackwardTransition()` to detect backward moves
- [ ] Returns `RejectionReasonRequiredError` when rejection reason missing
- [ ] Error includes task key, from/to status, and progress percentages
- [ ] Rejection reason stored in task_history when provided
- [ ] Empty/whitespace rejection reasons rejected (use `strings.TrimSpace`)
- [ ] Forward transitions work without rejection reason
- [ ] Transaction rolls back on error

## Testing Requirements

### Unit Tests

File: `internal/repository/task_repository_test.go`

```go
func TestTaskRepository_UpdateStatus_RequiresRejectionReason(t *testing.T) {
    ctx := context.Background()
    db := test.GetTestDB()
    repo := NewTaskRepository(db)

    // Clean up
    _, _ = db.ExecContext(ctx, "DELETE FROM tasks WHERE key LIKE 'TEST-%'")

    // Seed test data
    epicID, featureID := test.SeedTestData()

    // Create task in ready_for_code_review status
    task := &models.Task{
        Key:       "TEST-E07-F22-001",
        Title:     "Test Task",
        Status:    "ready_for_code_review",
        EpicID:    epicID,
        FeatureID: featureID,
    }

    err := repo.Create(ctx, task)
    if err != nil {
        t.Fatalf("Create() failed: %v", err)
    }
    defer db.ExecContext(ctx, "DELETE FROM tasks WHERE id = ?", task.ID)

    // Set config to require rejection reason
    cfg := config.Get()
    originalValue := cfg.RequireRejectionReason
    cfg.RequireRejectionReason = true
    defer func() { cfg.RequireRejectionReason = originalValue }()

    // Attempt backward transition WITHOUT rejection reason
    opts := UpdateStatusOptions{} // Empty rejection reason
    err = repo.UpdateStatus(ctx, task.Key, "in_development", opts)

    // Should fail with RejectionReasonRequiredError
    if err == nil {
        t.Fatal("expected error when rejection reason missing")
    }

    var rejErr *RejectionReasonRequiredError
    if !errors.As(err, &rejErr) {
        t.Fatalf("expected RejectionReasonRequiredError, got: %T", err)
    }

    // Verify error details
    if rejErr.TaskKey != task.Key {
        t.Errorf("expected task_key %s, got %s", task.Key, rejErr.TaskKey)
    }
    if rejErr.FromStatus != "ready_for_code_review" {
        t.Errorf("expected from_status ready_for_code_review, got %s", rejErr.FromStatus)
    }
    if rejErr.ToStatus != "in_development" {
        t.Errorf("expected to_status in_development, got %s", rejErr.ToStatus)
    }

    // Verify task status NOT changed
    updated, err := repo.GetByKey(ctx, task.Key)
    if err != nil {
        t.Fatalf("GetByKey() failed: %v", err)
    }
    if updated.Status != "ready_for_code_review" {
        t.Errorf("task status should not change on error, got: %s", updated.Status)
    }
}

func TestTaskRepository_UpdateStatus_WithRejectionReason(t *testing.T) {
    ctx := context.Background()
    db := test.GetTestDB()
    repo := NewTaskRepository(db)

    // Clean up
    _, _ = db.ExecContext(ctx, "DELETE FROM tasks WHERE key LIKE 'TEST-%'")

    // Seed and create task
    epicID, featureID := test.SeedTestData()
    task := &models.Task{
        Key:       "TEST-E07-F22-002",
        Title:     "Test Task",
        Status:    "ready_for_code_review",
        EpicID:    epicID,
        FeatureID: featureID,
    }
    err := repo.Create(ctx, task)
    if err != nil {
        t.Fatalf("Create() failed: %v", err)
    }
    defer db.ExecContext(ctx, "DELETE FROM tasks WHERE id = ?", task.ID)

    // Enable rejection reason requirement
    cfg := config.Get()
    originalValue := cfg.RequireRejectionReason
    cfg.RequireRejectionReason = true
    defer func() { cfg.RequireRejectionReason = originalValue }()

    // Backward transition WITH rejection reason
    opts := UpdateStatusOptions{
        RejectionReason: "Missing error handling for edge cases",
        Agent:           "test-agent",
    }
    err = repo.UpdateStatus(ctx, task.Key, "in_development", opts)
    if err != nil {
        t.Fatalf("UpdateStatus() failed: %v", err)
    }

    // Verify task status updated
    updated, err := repo.GetByKey(ctx, task.Key)
    if err != nil {
        t.Fatalf("GetByKey() failed: %v", err)
    }
    if updated.Status != "in_development" {
        t.Errorf("expected status in_development, got: %s", updated.Status)
    }

    // Verify history recorded with rejection reason
    historyRepo := NewTaskHistoryRepository(db)
    history, err := historyRepo.GetByTaskID(ctx, task.ID)
    if err != nil {
        t.Fatalf("GetByTaskID() failed: %v", err)
    }

    if len(history) == 0 {
        t.Fatal("expected history entry")
    }

    lastEntry := history[0] // Most recent first
    if lastEntry.RejectionReason != "Missing error handling for edge cases" {
        t.Errorf("expected rejection reason in history, got: %s", lastEntry.RejectionReason)
    }
    if lastEntry.Agent != "test-agent" {
        t.Errorf("expected agent test-agent, got: %s", lastEntry.Agent)
    }
}

func TestTaskRepository_UpdateStatus_ForwardTransition_NoRejectionNeeded(t *testing.T) {
    ctx := context.Background()
    db := test.GetTestDB()
    repo := NewTaskRepository(db)

    // Clean up
    _, _ = db.ExecContext(ctx, "DELETE FROM tasks WHERE key LIKE 'TEST-%'")

    // Seed and create task
    epicID, featureID := test.SeedTestData()
    task := &models.Task{
        Key:       "TEST-E07-F22-003",
        Title:     "Test Task",
        Status:    "in_development",
        EpicID:    epicID,
        FeatureID: featureID,
    }
    err := repo.Create(ctx, task)
    if err != nil {
        t.Fatalf("Create() failed: %v", err)
    }
    defer db.ExecContext(ctx, "DELETE FROM tasks WHERE id = ?", task.ID)

    // Enable rejection reason requirement
    cfg := config.Get()
    cfg.RequireRejectionReason = true

    // Forward transition WITHOUT rejection reason (should succeed)
    opts := UpdateStatusOptions{} // No rejection reason
    err = repo.UpdateStatus(ctx, task.Key, "ready_for_code_review", opts)
    if err != nil {
        t.Fatalf("UpdateStatus() should succeed for forward transitions: %v", err)
    }

    // Verify status updated
    updated, err := repo.GetByKey(ctx, task.Key)
    if err != nil {
        t.Fatalf("GetByKey() failed: %v", err)
    }
    if updated.Status != "ready_for_code_review" {
        t.Errorf("expected status ready_for_code_review, got: %s", updated.Status)
    }
}

func TestTaskRepository_UpdateStatus_WhitespaceRejectionReason(t *testing.T) {
    ctx := context.Background()
    db := test.GetTestDB()
    repo := NewTaskRepository(db)

    // Clean up
    _, _ = db.ExecContext(ctx, "DELETE FROM tasks WHERE key LIKE 'TEST-%'")

    // Seed and create task
    epicID, featureID := test.SeedTestData()
    task := &models.Task{
        Key:       "TEST-E07-F22-004",
        Title:     "Test Task",
        Status:    "ready_for_code_review",
        EpicID:    epicID,
        FeatureID: featureID,
    }
    err := repo.Create(ctx, task)
    if err != nil {
        t.Fatalf("Create() failed: %v", err)
    }
    defer db.ExecContext(ctx, "DELETE FROM tasks WHERE id = ?", task.ID)

    // Enable rejection reason requirement
    cfg := config.Get()
    cfg.RequireRejectionReason = true

    // Backward transition with whitespace-only rejection reason
    opts := UpdateStatusOptions{
        RejectionReason: "   ", // Whitespace only
    }
    err = repo.UpdateStatus(ctx, task.Key, "in_development", opts)

    // Should fail (whitespace not valid)
    if err == nil {
        t.Fatal("expected error for whitespace-only rejection reason")
    }

    var rejErr *RejectionReasonRequiredError
    if !errors.As(err, &rejErr) {
        t.Errorf("expected RejectionReasonRequiredError, got: %T", err)
    }
}
```

## Notes

- **Transaction Safety:** Entire update (status + history) in single transaction
- **Whitespace Handling:** Use `strings.TrimSpace()` to reject empty/whitespace reasons
- **Config-Driven:** Behavior controlled by `require_rejection_reason` config option
- **Backward Detection:** Uses `cfg.IsBackwardTransition()` from T-E07-F22-025
- **Error Details:** Include progress percentages for user-friendly error messages
