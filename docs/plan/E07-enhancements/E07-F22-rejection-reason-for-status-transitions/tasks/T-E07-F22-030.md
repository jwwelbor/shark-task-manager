---
agent: backend
created_at: 2026-01-16T20:10:50Z
dependencies:
    - T-E07-F22-024
    - T-E07-F22-025
    - T-E07-F22-026
    - T-E07-F22-027
    - T-E07-F22-029
epic: E07
feature: E07-F22
key: T-E07-F22-030
priority: 7
status: todo
task_key: T-E07-F22-017
title: Add tests for rejection reason validation
---


# Task: Add tests for rejection reason validation

## Goal

Add comprehensive test suite covering all aspects of rejection reason validation, including database migrations, config detection, repository validation, CLI integration, and edge cases.

This task consolidates all testing requirements from previous tasks into a comprehensive test suite.

## Test Categories

### 1. Database Migration Tests

File: `internal/db/db_test.go`

```go
func TestMigration_RejectionReason(t *testing.T) {
    // Test from T-E07-F22-024
    db, cleanup := createTestDB(t)
    defer cleanup()

    err := InitDB(db)
    if err != nil {
        t.Fatalf("migration failed: %v", err)
    }

    // Verify column exists
    var columnExists int
    err = db.QueryRow(`
        SELECT COUNT(*)
        FROM pragma_table_info('task_history')
        WHERE name = 'rejection_reason'
    `).Scan(&columnExists)

    if columnExists != 1 {
        t.Error("rejection_reason column not found")
    }

    // Verify index exists
    var indexExists int
    err = db.QueryRow(`
        SELECT COUNT(*)
        FROM sqlite_master
        WHERE type='index' AND name='idx_task_history_rejection'
    `).Scan(&indexExists)

    if indexExists != 1 {
        t.Error("idx_task_history_rejection index not found")
    }
}

func TestMigration_RejectionReason_Idempotent(t *testing.T) {
    // Test from T-E07-F22-024
    db, cleanup := createTestDB(t)
    defer cleanup()

    // First migration
    err := InitDB(db)
    if err != nil {
        t.Fatalf("first migration failed: %v", err)
    }

    // Second migration (should not fail)
    err = InitDB(db)
    if err != nil {
        t.Fatalf("second migration failed: %v", err)
    }
}
```

### 2. Config Tests (IsBackwardTransition)

File: `internal/config/config_test.go`

```go
func TestConfig_IsBackwardTransition(t *testing.T) {
    // Test from T-E07-F22-025
    cfg := &Config{
        StatusMetadata: map[string]StatusMetadata{
            "draft":                 {ProgressWeight: 0.10},
            "in_development":        {ProgressWeight: 0.50},
            "ready_for_code_review": {ProgressWeight: 0.85},
            "completed":             {ProgressWeight: 1.0},
        },
    }

    tests := []struct {
        name         string
        oldStatus    string
        newStatus    string
        wantBackward bool
    }{
        {"backward: review to dev", "ready_for_code_review", "in_development", true},
        {"backward: completed to review", "completed", "ready_for_code_review", true},
        {"forward: dev to review", "in_development", "ready_for_code_review", false},
        {"equal: same status", "in_development", "in_development", false},
        {"missing old status", "unknown", "in_development", false},
        {"missing new status", "in_development", "unknown", false},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := cfg.IsBackwardTransition(tt.oldStatus, tt.newStatus)
            if result != tt.wantBackward {
                t.Errorf("IsBackwardTransition(%q, %q) = %v, want %v",
                    tt.oldStatus, tt.newStatus, result, tt.wantBackward)
            }
        })
    }
}

func TestConfig_RequireRejectionReason_Parsing(t *testing.T) {
    // Test from T-E07-F22-029
    tests := []struct {
        name    string
        json    string
        want    bool
        wantErr bool
    }{
        {"explicitly true", `{"require_rejection_reason": true}`, true, false},
        {"explicitly false", `{"require_rejection_reason": false}`, false, false},
        {"omitted (default)", `{}`, false, false},
        {"invalid type", `{"require_rejection_reason": "yes"}`, false, true},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            var cfg Config
            err := json.Unmarshal([]byte(tt.json), &cfg)

            if (err != nil) != tt.wantErr {
                t.Errorf("Unmarshal() error = %v, wantErr %v", err, tt.wantErr)
                return
            }

            if !tt.wantErr && cfg.RequireRejectionReason != tt.want {
                t.Errorf("RequireRejectionReason = %v, want %v", cfg.RequireRejectionReason, tt.want)
            }
        })
    }
}
```

### 3. Repository Tests (UpdateStatus Validation)

File: `internal/repository/task_repository_test.go`

```go
func TestTaskRepository_UpdateStatus_RequiresRejectionReason(t *testing.T) {
    // Test from T-E07-F22-026
    ctx := context.Background()
    db := test.GetTestDB()
    repo := NewTaskRepository(db)

    // Clean up
    _, _ = db.ExecContext(ctx, "DELETE FROM tasks WHERE key LIKE 'TEST-%'")

    // Seed test data
    epicID, featureID := test.SeedTestData()

    // Create task in ready_for_code_review status
    task := &models.Task{
        Key:       "TEST-E07-F22-001",
        Title:     "Test Task",
        Status:    "ready_for_code_review",
        EpicID:    epicID,
        FeatureID: featureID,
    }

    err := repo.Create(ctx, task)
    if err != nil {
        t.Fatalf("Create() failed: %v", err)
    }
    defer db.ExecContext(ctx, "DELETE FROM tasks WHERE id = ?", task.ID)

    // Enable rejection reason requirement
    cfg := config.Get()
    originalValue := cfg.RequireRejectionReason
    cfg.RequireRejectionReason = true
    defer func() { cfg.RequireRejectionReason = originalValue }()

    // Attempt backward transition WITHOUT rejection reason
    opts := UpdateStatusOptions{}
    err = repo.UpdateStatus(ctx, task.Key, "in_development", opts)

    // Should fail with RejectionReasonRequiredError
    if err == nil {
        t.Fatal("expected error when rejection reason missing")
    }

    var rejErr *RejectionReasonRequiredError
    if !errors.As(err, &rejErr) {
        t.Fatalf("expected RejectionReasonRequiredError, got: %T", err)
    }

    // Verify error details
    if rejErr.TaskKey != task.Key {
        t.Errorf("expected task_key %s, got %s", task.Key, rejErr.TaskKey)
    }

    // Verify task status NOT changed
    updated, err := repo.GetByKey(ctx, task.Key)
    if err != nil {
        t.Fatalf("GetByKey() failed: %v", err)
    }
    if updated.Status != "ready_for_code_review" {
        t.Errorf("task status should not change on error, got: %s", updated.Status)
    }
}

func TestTaskRepository_UpdateStatus_WithRejectionReason(t *testing.T) {
    // Test from T-E07-F22-026
    ctx := context.Background()
    db := test.GetTestDB()
    repo := NewTaskRepository(db)

    // Clean up
    _, _ = db.ExecContext(ctx, "DELETE FROM tasks WHERE key LIKE 'TEST-%'")

    // Seed and create task
    epicID, featureID := test.SeedTestData()
    task := &models.Task{
        Key:       "TEST-E07-F22-002",
        Title:     "Test Task",
        Status:    "ready_for_code_review",
        EpicID:    epicID,
        FeatureID: featureID,
    }
    err := repo.Create(ctx, task)
    if err != nil {
        t.Fatalf("Create() failed: %v", err)
    }
    defer db.ExecContext(ctx, "DELETE FROM tasks WHERE id = ?", task.ID)

    // Enable rejection reason requirement
    cfg := config.Get()
    cfg.RequireRejectionReason = true

    // Backward transition WITH rejection reason
    opts := UpdateStatusOptions{
        RejectionReason: "Missing error handling for edge cases",
        Agent:           "test-agent",
    }
    err = repo.UpdateStatus(ctx, task.Key, "in_development", opts)
    if err != nil {
        t.Fatalf("UpdateStatus() failed: %v", err)
    }

    // Verify task status updated
    updated, err := repo.GetByKey(ctx, task.Key)
    if err != nil {
        t.Fatalf("GetByKey() failed: %v", err)
    }
    if updated.Status != "in_development" {
        t.Errorf("expected status in_development, got: %s", updated.Status)
    }

    // Verify history recorded with rejection reason
    historyRepo := NewTaskHistoryRepository(db)
    history, err := historyRepo.GetByTaskID(ctx, task.ID)
    if err != nil {
        t.Fatalf("GetByTaskID() failed: %v", err)
    }

    if len(history) == 0 {
        t.Fatal("expected history entry")
    }

    lastEntry := history[0]
    if lastEntry.RejectionReason != "Missing error handling for edge cases" {
        t.Errorf("expected rejection reason in history, got: %s", lastEntry.RejectionReason)
    }
}

func TestTaskRepository_UpdateStatus_ForwardTransition_NoRejectionNeeded(t *testing.T) {
    // Test from T-E07-F22-026
    ctx := context.Background()
    db := test.GetTestDB()
    repo := NewTaskRepository(db)

    // Clean up
    _, _ = db.ExecContext(ctx, "DELETE FROM tasks WHERE key LIKE 'TEST-%'")

    epicID, featureID := test.SeedTestData()
    task := &models.Task{
        Key:       "TEST-E07-F22-003",
        Title:     "Test Task",
        Status:    "in_development",
        EpicID:    epicID,
        FeatureID: featureID,
    }
    err := repo.Create(ctx, task)
    if err != nil {
        t.Fatalf("Create() failed: %v", err)
    }
    defer db.ExecContext(ctx, "DELETE FROM tasks WHERE id = ?", task.ID)

    cfg := config.Get()
    cfg.RequireRejectionReason = true

    // Forward transition WITHOUT rejection reason (should succeed)
    opts := UpdateStatusOptions{}
    err = repo.UpdateStatus(ctx, task.Key, "ready_for_code_review", opts)
    if err != nil {
        t.Fatalf("UpdateStatus() should succeed for forward transitions: %v", err)
    }
}

func TestTaskRepository_UpdateStatus_WhitespaceRejectionReason(t *testing.T) {
    // Test from T-E07-F22-026
    ctx := context.Background()
    db := test.GetTestDB()
    repo := NewTaskRepository(db)

    // Clean up
    _, _ = db.ExecContext(ctx, "DELETE FROM tasks WHERE key LIKE 'TEST-%'")

    epicID, featureID := test.SeedTestData()
    task := &models.Task{
        Key:       "TEST-E07-F22-004",
        Title:     "Test Task",
        Status:    "ready_for_code_review",
        EpicID:    epicID,
        FeatureID: featureID,
    }
    err := repo.Create(ctx, task)
    if err != nil {
        t.Fatalf("Create() failed: %v", err)
    }
    defer db.ExecContext(ctx, "DELETE FROM tasks WHERE id = ?", task.ID)

    cfg := config.Get()
    cfg.RequireRejectionReason = true

    // Backward transition with whitespace-only rejection reason
    opts := UpdateStatusOptions{
        RejectionReason: "   ", // Whitespace only
    }
    err = repo.UpdateStatus(ctx, task.Key, "in_development", opts)

    // Should fail (whitespace not valid)
    if err == nil {
        t.Fatal("expected error for whitespace-only rejection reason")
    }

    var rejErr *RejectionReasonRequiredError
    if !errors.As(err, &rejErr) {
        t.Errorf("expected RejectionReasonRequiredError, got: %T", err)
    }
}
```

### 4. End-to-End Integration Tests

File: `internal/integration/rejection_reason_test.go`

```go
func TestEndToEnd_RejectionReasonWorkflow(t *testing.T) {
    ctx := context.Background()
    db := test.GetTestDB()

    // Enable rejection reason requirement
    cfg := config.Get()
    cfg.RequireRejectionReason = true

    // Clean up
    _, _ = db.ExecContext(ctx, "DELETE FROM tasks WHERE key LIKE 'TEST-%'")

    // Create epic and feature
    epicRepo := repository.NewEpicRepository(db)
    featureRepo := repository.NewFeatureRepository(db)
    taskRepo := repository.NewTaskRepository(db)

    epic := &models.Epic{Key: "TEST-E07", Title: "Test Epic"}
    err := epicRepo.Create(ctx, epic)
    if err != nil {
        t.Fatalf("failed to create epic: %v", err)
    }
    defer db.ExecContext(ctx, "DELETE FROM epics WHERE id = ?", epic.ID)

    feature := &models.Feature{Key: "TEST-E07-F22", EpicID: epic.ID, Title: "Test Feature"}
    err = featureRepo.Create(ctx, feature)
    if err != nil {
        t.Fatalf("failed to create feature: %v", err)
    }
    defer db.ExecContext(ctx, "DELETE FROM features WHERE id = ?", feature.ID)

    // Create task
    task := &models.Task{
        Key:       "TEST-E07-F22-001",
        Title:     "Test Task",
        Status:    "draft",
        EpicID:    epic.ID,
        FeatureID: feature.ID,
    }
    err = taskRepo.Create(ctx, task)
    if err != nil {
        t.Fatalf("failed to create task: %v", err)
    }
    defer db.ExecContext(ctx, "DELETE FROM tasks WHERE id = ?", task.ID)

    // Move task forward (no rejection reason needed)
    err = taskRepo.UpdateStatus(ctx, task.Key, "in_development", repository.UpdateStatusOptions{})
    if err != nil {
        t.Fatalf("forward transition failed: %v", err)
    }

    err = taskRepo.UpdateStatus(ctx, task.Key, "ready_for_code_review", repository.UpdateStatusOptions{})
    if err != nil {
        t.Fatalf("forward transition failed: %v", err)
    }

    // Try to move backward WITHOUT rejection reason (should fail)
    err = taskRepo.UpdateStatus(ctx, task.Key, "in_development", repository.UpdateStatusOptions{})
    if err == nil {
        t.Fatal("expected error for backward transition without rejection reason")
    }

    var rejErr *repository.RejectionReasonRequiredError
    if !errors.As(err, &rejErr) {
        t.Fatalf("expected RejectionReasonRequiredError, got: %T", err)
    }

    // Move backward WITH rejection reason (should succeed)
    opts := repository.UpdateStatusOptions{
        RejectionReason: "Failed code review: missing tests",
    }
    err = taskRepo.UpdateStatus(ctx, task.Key, "in_development", opts)
    if err != nil {
        t.Fatalf("backward transition with rejection reason failed: %v", err)
    }

    // Verify history contains rejection reason
    historyRepo := repository.NewTaskHistoryRepository(db)
    history, err := historyRepo.GetByTaskID(ctx, task.ID)
    if err != nil {
        t.Fatalf("failed to get history: %v", err)
    }

    foundRejection := false
    for _, h := range history {
        if h.RejectionReason == "Failed code review: missing tests" {
            foundRejection = true
            break
        }
    }

    if !foundRejection {
        t.Error("rejection reason not found in task history")
    }
}
```

## Implementation Steps

1. Create test files for each component (db, config, repository, CLI)
2. Implement database migration tests
3. Implement config parsing and validation tests
4. Implement repository UpdateStatus tests
5. Implement CLI command tests
6. Add end-to-end integration tests
7. Run full test suite and verify coverage
8. Document test coverage requirements

## Acceptance Criteria

- [ ] Database migration tests pass (idempotent, column exists, index exists)
- [ ] Config tests pass (parsing, validation, backward detection)
- [ ] Repository tests pass (validation, history recording, transactions)
- [ ] CLI tests pass (error handling, user messaging)
- [ ] Integration tests pass (full workflow)
- [ ] Test coverage > 80% for new code
- [ ] All edge cases tested (whitespace, missing metadata, nil config)
- [ ] Tests run in CI/CD pipeline

## Test Coverage Requirements

Target coverage for each component:

- **Database migrations:** 100% (critical path)
- **Config validation:** 95% (cover all edge cases)
- **Repository UpdateStatus:** 90% (core business logic)
- **CLI commands:** 80% (user interface)
- **Integration tests:** End-to-end happy path + rejection scenarios

## Running Tests

```bash
# Run all tests
make test

# Run specific test suites
go test -v ./internal/db -run TestMigration_RejectionReason
go test -v ./internal/config -run TestConfig_IsBackwardTransition
go test -v ./internal/repository -run TestTaskRepository_UpdateStatus

# Run with coverage
make test-coverage
open coverage.html
```

## Notes

- **Test Isolation:** Clean up test data before each test
- **Test Determinism:** No random data, fixed timestamps
- **Test Speed:** Use test database, avoid unnecessary I/O
- **Test Coverage:** Focus on critical paths and edge cases
- **Test Documentation:** Clear test names describe what's being tested
