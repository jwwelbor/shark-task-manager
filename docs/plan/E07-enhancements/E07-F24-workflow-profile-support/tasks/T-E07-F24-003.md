---
task_key: T-E07-F24-003
feature_key: E07-F24
title: "Phase 3: Build profile service for orchestration"
status: todo
agent: backend
priority: 8
estimated_hours: 3-4
dependencies:
  - T-E07-F24-001
  - T-E07-F24-002
related_docs:
  - ../technical-design.md
  - ../specifications/business-requirements.md
---

# Task: Phase 3 - Profile Service Orchestration

**Feature**: E07-F24 - Workflow Profile Support
**Phase**: 3 of 6
**Estimated Time**: 3-4 hours

## Objective

Build the ProfileService that orchestrates profile application by coordinating profile loading, configuration merging, change tracking, backup creation, and atomic config writing.

## Files to Create

1. `internal/init/profile_service.go`
   - Define `ProfileService` struct
   - Implement `ApplyProfile()` method
   - Implement `GetChangePreview()` method
   - Implement `AddMissingFields()` method
   - Helper: `createConfigBackup()`
   - Helper: `writeConfig()` with atomic write
   - Helper: `profileToMap()` converter

2. `internal/init/profile_service_test.go`
   - Test apply basic profile
   - Test apply advanced profile
   - Test dry-run mode
   - Test force mode
   - Test preserve database config
   - Test preserve custom fields
   - Test add missing fields only
   - Test invalid profile error
   - Test backup creation

## Implementation Plan

### Step 1: Create ProfileService Struct (`profile_service.go`)

```go
package init

import (
    "fmt"
    "os"
    "path/filepath"
    "time"

    "github.com/jwwelbor/shark-task-manager/internal/config"
)

// ProfileService orchestrates profile application
type ProfileService struct {
    configManager *config.Manager
    merger        *ConfigMerger
}

// NewProfileService creates a new profile service
func NewProfileService(configPath string) *ProfileService {
    return &ProfileService{
        configManager: config.NewManager(configPath),
        merger:        NewConfigMerger(),
    }
}
```

### Step 2: Implement ApplyProfile Method

```go
// ApplyProfile applies a workflow profile to existing config
func (s *ProfileService) ApplyProfile(opts UpdateOptions) (*UpdateResult, error) {
    // 1. Load current config
    currentConfig, err := s.configManager.Load()
    if err != nil {
        // If config doesn't exist, create empty base
        if os.IsNotExist(err) {
            currentConfig = &config.Config{
                RawData: make(map[string]interface{}),
            }
        } else {
            return nil, fmt.Errorf("failed to load config: %w", err)
        }
    }

    // 2. Get profile (or use default for missing fields)
    var profile *WorkflowProfile
    if opts.WorkflowName != "" {
        profile, err = GetProfile(opts.WorkflowName)
        if err != nil {
            return nil, err
        }
    } else {
        // No workflow specified - use basic for adding missing fields
        profile = basicProfile
    }

    // 3. Convert profile to map
    profileMap := profileToMap(profile)

    // 4. Merge configs
    mergeOpts := ConfigMergeOptions{
        PreserveFields: []string{
            "database",
            "project_root",
            "viewer",
            "last_sync_time",
        },
        OverwriteFields: []string{
            "status_metadata",
            "status_flow",
            "special_statuses",
            "status_flow_version",
        },
        Force: opts.Force,
    }

    mergedConfig, changeReport, err := s.merger.Merge(
        currentConfig.RawData,
        profileMap,
        mergeOpts,
    )
    if err != nil {
        return nil, fmt.Errorf("failed to merge config: %w", err)
    }

    // 5. If dry run, return preview without writing
    if opts.DryRun {
        return &UpdateResult{
            Success:     true,
            ProfileName: profile.Name,
            Changes:     changeReport,
            ConfigPath:  opts.ConfigPath,
            DryRun:      true,
        }, nil
    }

    // 6. Create backup before writing
    backupPath, err := s.createConfigBackup(opts.ConfigPath)
    if err != nil {
        // Log warning but don't fail - backup is nice-to-have
        if opts.Verbose {
            fmt.Fprintf(os.Stderr, "Warning: failed to create backup: %v\n", err)
        }
    }

    // 7. Write merged config (atomic)
    if err := s.writeConfig(opts.ConfigPath, mergedConfig); err != nil {
        return nil, fmt.Errorf("failed to write config: %w", err)
    }

    return &UpdateResult{
        Success:     true,
        ProfileName: profile.Name,
        BackupPath:  backupPath,
        Changes:     changeReport,
        ConfigPath:  opts.ConfigPath,
        DryRun:      false,
    }, nil
}
```

### Step 3: Implement GetChangePreview

```go
// GetChangePreview shows what would change without applying
func (s *ProfileService) GetChangePreview(opts UpdateOptions) (*ChangeReport, error) {
    // Load current config
    currentConfig, err := s.configManager.Load()
    if err != nil {
        if os.IsNotExist(err) {
            currentConfig = &config.Config{
                RawData: make(map[string]interface{}),
            }
        } else {
            return nil, fmt.Errorf("failed to load config: %w", err)
        }
    }

    // Get profile
    var profile *WorkflowProfile
    if opts.WorkflowName != "" {
        profile, err = GetProfile(opts.WorkflowName)
        if err != nil {
            return nil, err
        }
    } else {
        profile = basicProfile
    }

    // Merge configs
    mergeOpts := ConfigMergeOptions{
        PreserveFields:  []string{"database", "project_root", "viewer", "last_sync_time"},
        OverwriteFields: []string{"status_metadata", "status_flow", "special_statuses"},
        Force:           opts.Force,
    }

    _, changeReport, err := s.merger.Merge(
        currentConfig.RawData,
        profileToMap(profile),
        mergeOpts,
    )
    if err != nil {
        return nil, fmt.Errorf("failed to generate preview: %w", err)
    }

    return changeReport, nil
}
```

### Step 4: Implement AddMissingFields

```go
// AddMissingFields adds missing config fields without overwriting existing
func (s *ProfileService) AddMissingFields(opts UpdateOptions) (*UpdateResult, error) {
    // Force opts.WorkflowName to empty and Force to false
    opts.WorkflowName = ""
    opts.Force = false

    // Use ApplyProfile with these settings
    // This will merge basic profile but preserve all existing fields
    return s.ApplyProfile(opts)
}
```

### Step 5: Implement Helper Functions

```go
// createConfigBackup creates a timestamped backup of the config file
func (s *ProfileService) createConfigBackup(configPath string) (string, error) {
    // Check if config file exists
    if _, err := os.Stat(configPath); os.IsNotExist(err) {
        return "", nil // No file to backup
    }

    // Read current config
    data, err := os.ReadFile(configPath)
    if err != nil {
        return "", fmt.Errorf("failed to read config: %w", err)
    }

    // Create backup filename with timestamp
    timestamp := time.Now().Format("20060102-150405")
    backupPath := fmt.Sprintf("%s.backup.%s", configPath, timestamp)

    // Write backup
    if err := os.WriteFile(backupPath, data, 0644); err != nil {
        return "", fmt.Errorf("failed to write backup: %w", err)
    }

    return backupPath, nil
}

// writeConfig writes config to file atomically
func (s *ProfileService) writeConfig(configPath string, data map[string]interface{}) error {
    // Use existing config manager's Save method
    // But first we need to convert map back to Config struct
    cfg := &config.Config{
        RawData: data,
    }

    // Marshal to JSON
    jsonData, err := cfg.Marshal()
    if err != nil {
        return fmt.Errorf("failed to marshal config: %w", err)
    }

    // Atomic write: write to temp file, then rename
    dir := filepath.Dir(configPath)
    tmpFile, err := os.CreateTemp(dir, ".sharkconfig.*.tmp")
    if err != nil {
        return fmt.Errorf("failed to create temp file: %w", err)
    }
    tmpPath := tmpFile.Name()

    // Cleanup temp file on error
    defer func() {
        if err != nil {
            os.Remove(tmpPath)
        }
    }()

    // Write to temp file
    if _, err := tmpFile.Write(jsonData); err != nil {
        tmpFile.Close()
        return fmt.Errorf("failed to write temp file: %w", err)
    }

    if err := tmpFile.Close(); err != nil {
        return fmt.Errorf("failed to close temp file: %w", err)
    }

    // Atomic rename
    if err := os.Rename(tmpPath, configPath); err != nil {
        return fmt.Errorf("failed to rename temp file: %w", err)
    }

    return nil
}

// profileToMap converts a WorkflowProfile to map[string]interface{}
func profileToMap(profile *WorkflowProfile) map[string]interface{} {
    result := make(map[string]interface{})

    // Add status_metadata
    if profile.StatusMetadata != nil {
        statusMap := make(map[string]interface{})
        for key, meta := range profile.StatusMetadata {
            statusMap[key] = map[string]interface{}{
                "color":           meta.Color,
                "phase":           meta.Phase,
                "progress_weight": meta.ProgressWeight,
                "responsibility":  meta.Responsibility,
                "blocks_feature":  meta.BlocksFeature,
                "description":     meta.Description,
            }
            if len(meta.AgentTypes) > 0 {
                statusMap[key].(map[string]interface{})["agent_types"] = meta.AgentTypes
            }
        }
        result["status_metadata"] = statusMap
    }

    // Add status_flow if present
    if profile.StatusFlow != nil && len(profile.StatusFlow) > 0 {
        result["status_flow"] = profile.StatusFlow
    }

    // Add special_statuses if present
    if profile.SpecialStatuses != nil && len(profile.SpecialStatuses) > 0 {
        result["special_statuses"] = profile.SpecialStatuses
    }

    // Add status_flow_version if present
    if profile.StatusFlowVersion != "" {
        result["status_flow_version"] = profile.StatusFlowVersion
    }

    // Add default fields
    result["color_enabled"] = true
    result["default_epic"] = nil
    result["default_agent"] = nil

    return result
}
```

### Step 6: Write Comprehensive Unit Tests

Tests to implement in `profile_service_test.go`:

```go
func TestApplyProfile_Basic(t *testing.T) {
    // Test applying basic profile to empty config
}

func TestApplyProfile_Advanced(t *testing.T) {
    // Test applying advanced profile to empty config
}

func TestApplyProfile_DryRun(t *testing.T) {
    // Test dry-run doesn't write files
}

func TestApplyProfile_Force(t *testing.T) {
    // Test force mode overwrites existing
}

func TestApplyProfile_PreserveDatabase(t *testing.T) {
    // Test database config never overwritten
}

func TestApplyProfile_PreserveCustomFields(t *testing.T) {
    // Test custom fields preserved
}

func TestAddMissingFields(t *testing.T) {
    // Test adding missing fields without overwriting
}

func TestApplyProfile_InvalidProfile(t *testing.T) {
    // Test error handling for invalid profile names
}

func TestApplyProfile_BackupCreated(t *testing.T) {
    // Test backup file created before write
}

func TestGetChangePreview(t *testing.T) {
    // Test preview generation without applying
}

func TestWriteConfig_Atomic(t *testing.T) {
    // Test atomic write doesn't leave partial files
}
```

## Acceptance Criteria

- [x] **AC1**: `ApplyProfile()` applies basic profile successfully
- [x] **AC2**: `ApplyProfile()` applies advanced profile successfully
- [x] **AC3**: Dry-run mode doesn't write files
- [x] **AC4**: Backup created before writing (with timestamp)
- [x] **AC5**: Database config always preserved (unless force mode)
- [x] **AC6**: Custom fields preserved when not in overwrite list
- [x] **AC7**: `AddMissingFields()` adds missing fields only
- [x] **AC8**: Invalid profile name returns descriptive error
- [x] **AC9**: Atomic write prevents partial config corruption
- [x] **AC10**: All unit tests pass with >85% coverage
- [x] **AC11**: Service handles missing config file gracefully

## Test Plan

### Unit Tests

```bash
# Run service tests
go test -v ./internal/init -run TestApplyProfile
go test -v ./internal/init -run TestAddMissingFields
go test -v ./internal/init -run TestGetChangePreview

# Check coverage
go test -cover ./internal/init -run "TestApply|TestAdd|TestGet"
```

### Test Scenarios

**Scenario 1: Apply to empty config**
```go
// Input: {} (empty)
// Profile: basic
// Expected: Complete basic profile config created
```

**Scenario 2: Apply to partial config**
```go
// Input: {"database": {"backend": "local"}}
// Profile: advanced
// Expected: Database preserved, advanced profile added
```

**Scenario 3: Dry run**
```go
// Input: existing config
// Profile: basic
// Dry-run: true
// Expected: ChangeReport returned, no file written
```

**Scenario 4: Add missing fields**
```go
// Input: {"database": {...}, "color_enabled": true}
// Expected: Missing fields added, existing preserved
```

## Dependencies

**Requires**:
- T-E07-F24-001 (Phase 1: Data structures - WorkflowProfile, UpdateOptions)
- T-E07-F24-002 (Phase 2: ConfigMerger for merge logic)

**Blocks**:
- T-E07-F24-004 (Phase 4: CLI command needs ProfileService)

## Design References

- **Technical Design**: Section "Component Design - ProfileService" (lines 242-271)
- **ApplyProfile Implementation**: Section "File-by-File Implementation" (lines 422-513)
- **Backup Strategy**: Section "Risk Assessment" (lines 1178-1215)

## Success Indicators

✅ ApplyProfile works for both basic and advanced profiles
✅ Dry-run mode shows changes without applying
✅ Backup created with timestamp before every write
✅ Atomic write prevents config corruption
✅ Database config always preserved
✅ Custom fields preserved correctly
✅ Error messages clear and actionable
✅ >85% test coverage
✅ All tests pass

## Notes

- **Backup Format**: `.sharkconfig.json.backup.YYYYMMDD-HHMMSS`
- **Atomic Write**: Use temp file + rename to prevent corruption
- **Error Handling**: Continue if backup fails (log warning only)
- Use existing `config.Manager` for config I/O
- ProfileToMap must handle optional fields (status_flow, special_statuses)
- Handle missing config file gracefully (create new config)
- Preserve unknown fields in RawData for forward compatibility

## Estimated Breakdown

- ProfileService struct and constructor: 15 min
- ApplyProfile() implementation: 60 min
- GetChangePreview() implementation: 20 min
- AddMissingFields() implementation: 10 min
- createConfigBackup() implementation: 20 min
- writeConfig() atomic write: 30 min
- profileToMap() converter: 25 min
- Unit tests (11 test functions): 60-90 min
- **Total**: 3-4 hours
