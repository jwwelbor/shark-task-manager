---
task_key: T-E07-F24-002
feature_key: E07-F24
title: "Phase 2: Implement config merger with smart merge logic"
status: todo
agent: backend
priority: 8
estimated_hours: 3-4
dependencies:
  - T-E07-F24-001
related_docs:
  - ../technical-design.md
  - ../specifications/business-requirements.md
---

# Task: Phase 2 - Config Merger with Smart Merge Logic

**Feature**: E07-F24 - Workflow Profile Support
**Phase**: 2 of 6
**Estimated Time**: 3-4 hours

## Objective

Implement the ConfigMerger component that intelligently merges workflow profile configurations with existing user configurations while preserving protected fields and tracking all changes.

## Files to Create

1. `internal/init/config_merger.go`
   - Define `ConfigMerger` struct
   - Implement `Merge()` with deep merge logic
   - Implement `DeepMerge()` for recursive map merging
   - Implement `DetectChanges()` for change tracking
   - Implement `calculateStats()` for detailed statistics
   - Helper functions: `deepCopy()`, `contains()`, `mergeValue()`

2. `internal/init/config_merger_test.go`
   - Test merge with add missing fields
   - Test merge with preserve fields
   - Test merge with overwrite fields
   - Test nested map merging
   - Test force mode
   - Test change detection
   - Test statistics calculation

## Implementation Plan

### Step 1: Create ConfigMerger Struct (`config_merger.go`)

```go
package init

import (
    "fmt"
)

// ConfigMerger handles intelligent configuration merging
type ConfigMerger struct {
    // No state needed - stateless service
}

// NewConfigMerger creates a new config merger instance
func NewConfigMerger() *ConfigMerger {
    return &ConfigMerger{}
}

// ConfigMergeOptions controls merge behavior
type ConfigMergeOptions struct {
    PreserveFields  []string  // Fields to never overwrite
    OverwriteFields []string  // Fields to replace
    Force           bool      // If true, overwrite even protected fields
}
```

### Step 2: Implement Merge Logic

```go
// Merge performs intelligent merge of overlay into base
// Returns merged config and change report
func (m *ConfigMerger) Merge(
    base, overlay map[string]interface{},
    opts ConfigMergeOptions,
) (map[string]interface{}, *ChangeReport, error) {
    // 1. Deep copy base to avoid mutations
    merged := deepCopy(base)

    // 2. Track changes
    report := &ChangeReport{
        Added:       []string{},
        Preserved:   []string{},
        Overwritten: []string{},
        Stats:       &ChangeStats{},
    }

    // 3. Process each field in overlay
    for key, value := range overlay {
        // Skip if in preserve list (unless force mode)
        if contains(opts.PreserveFields, key) && !opts.Force {
            report.Preserved = append(report.Preserved, key)
            continue
        }

        // Check if field exists in base
        if _, exists := merged[key]; exists {
            // Field exists - check if we should overwrite
            if contains(opts.OverwriteFields, key) || opts.Force {
                merged[key] = value
                report.Overwritten = append(report.Overwritten, key)
            } else {
                // Merge nested structures
                merged[key] = m.mergeValue(merged[key], value)
                report.Added = append(report.Added, key)
            }
        } else {
            // New field - add it
            merged[key] = value
            report.Added = append(report.Added, key)
        }
    }

    // 4. Calculate statistics
    report.Stats = m.calculateStats(base, merged, overlay)

    return merged, report, nil
}
```

### Step 3: Implement DeepMerge for Nested Maps

```go
// mergeValue handles merging of nested values
func (m *ConfigMerger) mergeValue(base, overlay interface{}) interface{} {
    // Handle maps recursively
    baseMap, baseIsMap := base.(map[string]interface{})
    overlayMap, overlayIsMap := overlay.(map[string]interface{})

    if baseIsMap && overlayIsMap {
        return m.DeepMerge(baseMap, overlayMap)
    }

    // For non-maps, overlay wins
    return overlay
}

// DeepMerge recursively merges two maps
func (m *ConfigMerger) DeepMerge(base, overlay map[string]interface{}) map[string]interface{} {
    result := deepCopy(base)

    for key, value := range overlay {
        if baseValue, exists := result[key]; exists {
            result[key] = m.mergeValue(baseValue, value)
        } else {
            result[key] = value
        }
    }

    return result
}
```

### Step 4: Implement Change Detection and Statistics

```go
// DetectChanges compares two configs and reports differences
func (m *ConfigMerger) DetectChanges(old, new map[string]interface{}) *ChangeReport {
    report := &ChangeReport{
        Added:       []string{},
        Preserved:   []string{},
        Overwritten: []string{},
        Stats:       &ChangeStats{},
    }

    // Find added and modified fields
    for key, newValue := range new {
        if oldValue, exists := old[key]; exists {
            // Check if value changed
            if !deepEqual(oldValue, newValue) {
                report.Overwritten = append(report.Overwritten, key)
            } else {
                report.Preserved = append(report.Preserved, key)
            }
        } else {
            report.Added = append(report.Added, key)
        }
    }

    report.Stats = m.calculateStats(old, new, new)
    return report
}

// calculateStats computes detailed change statistics
func (m *ConfigMerger) calculateStats(base, merged, overlay map[string]interface{}) *ChangeStats {
    stats := &ChangeStats{}

    // Count statuses added
    if statusMeta, ok := overlay["status_metadata"].(map[string]interface{}); ok {
        stats.StatusesAdded = len(statusMeta)
    }

    // Count flows added
    if statusFlow, ok := overlay["status_flow"].(map[string]interface{}); ok {
        stats.FlowsAdded = len(statusFlow)
    }

    // Count special status groups
    if specialStatuses, ok := overlay["special_statuses"].(map[string]interface{}); ok {
        stats.GroupsAdded = len(specialStatuses)
    }

    // Count preserved fields
    for key := range base {
        if _, exists := overlay[key]; !exists {
            stats.FieldsPreserved++
        }
    }

    return stats
}
```

### Step 5: Implement Helper Functions

```go
// deepCopy creates a deep copy of a map
func deepCopy(src map[string]interface{}) map[string]interface{} {
    dst := make(map[string]interface{})

    for key, value := range src {
        switch v := value.(type) {
        case map[string]interface{}:
            dst[key] = deepCopy(v)
        case []interface{}:
            dst[key] = deepCopySlice(v)
        default:
            dst[key] = v
        }
    }

    return dst
}

// deepCopySlice creates a deep copy of a slice
func deepCopySlice(src []interface{}) []interface{} {
    dst := make([]interface{}, len(src))

    for i, value := range src {
        switch v := value.(type) {
        case map[string]interface{}:
            dst[i] = deepCopy(v)
        case []interface{}:
            dst[i] = deepCopySlice(v)
        default:
            dst[i] = v
        }
    }

    return dst
}

// contains checks if a string is in a slice
func contains(slice []string, item string) bool {
    for _, s := range slice {
        if s == item {
            return true
        }
    }
    return false
}

// deepEqual checks if two values are deeply equal
func deepEqual(a, b interface{}) bool {
    aMap, aIsMap := a.(map[string]interface{})
    bMap, bIsMap := b.(map[string]interface{})

    if aIsMap && bIsMap {
        if len(aMap) != len(bMap) {
            return false
        }
        for key, aValue := range aMap {
            bValue, exists := bMap[key]
            if !exists || !deepEqual(aValue, bValue) {
                return false
            }
        }
        return true
    }

    // For non-maps, use simple equality
    return a == b
}
```

### Step 6: Write Comprehensive Unit Tests

Tests to implement in `config_merger_test.go`:

```go
func TestMerge_AddMissingFields(t *testing.T) {
    // Test adding new fields to existing config
}

func TestMerge_PreserveFields(t *testing.T) {
    // Test that preserve list is respected
}

func TestMerge_OverwriteFields(t *testing.T) {
    // Test that overwrite list replaces fields
}

func TestMerge_NestedMaps(t *testing.T) {
    // Test deep merge of nested structures
}

func TestMerge_Force(t *testing.T) {
    // Test force mode overwrites protected fields
}

func TestDeepMerge_Simple(t *testing.T) {
    // Test simple map merge
}

func TestDeepMerge_Nested(t *testing.T) {
    // Test nested map merge
}

func TestDetectChanges(t *testing.T) {
    // Test change detection accuracy
}

func TestCalculateStats(t *testing.T) {
    // Test statistics calculation
}

func TestMerge_EmptyBase(t *testing.T) {
    // Test merge into empty config
}

func TestMerge_EmptyOverlay(t *testing.T) {
    // Test merge with empty overlay
}
```

## Acceptance Criteria

- [x] **AC1**: `Merge()` preserves fields in preserve list (database, viewer, etc.)
- [x] **AC2**: `Merge()` overwrites fields in overwrite list (status_metadata, etc.)
- [x] **AC3**: `Merge()` adds missing fields from overlay
- [x] **AC4**: `DeepMerge()` recursively merges nested maps correctly
- [x] **AC5**: Force mode overwrites all fields except database config
- [x] **AC6**: `DetectChanges()` accurately reports all changes
- [x] **AC7**: `calculateStats()` returns correct counts
- [x] **AC8**: Deep copy prevents mutation of original config
- [x] **AC9**: All unit tests pass with >85% coverage
- [x] **AC10**: No memory leaks or goroutine leaks

## Test Plan

### Unit Tests

```bash
# Run merger tests
go test -v ./internal/init -run TestMerge
go test -v ./internal/init -run TestDeepMerge
go test -v ./internal/init -run TestDetectChanges

# Check coverage
go test -cover ./internal/init -run "TestMerge|TestDeep"
```

### Test Scenarios

**Scenario 1: Add missing fields**
```go
base := map[string]interface{}{
    "database": map[string]interface{}{"backend": "local"},
}
overlay := map[string]interface{}{
    "status_metadata": map[string]interface{}{"todo": {...}},
}
// Expected: merged has both database and status_metadata
```

**Scenario 2: Preserve database config**
```go
opts := ConfigMergeOptions{
    PreserveFields: []string{"database"},
}
// Expected: database from base is preserved
```

**Scenario 3: Deep merge nested maps**
```go
base := map[string]interface{}{
    "settings": map[string]interface{}{"color": true},
}
overlay := map[string]interface{}{
    "settings": map[string]interface{}{"verbose": true},
}
// Expected: settings has both color and verbose
```

## Dependencies

**Requires**:
- T-E07-F24-001 (Phase 1: Data structures needed for ChangeReport)

**Blocks**:
- T-E07-F24-003 (Phase 3: Profile Service needs ConfigMerger)

## Design References

- **Technical Design**: Section "Component Design - ConfigMerger" (lines 272-348)
- **Merge Algorithm**: Section "Configuration Merge Strategy" (lines 854-980)
- **Merge Rules**: Preserve list, overwrite list, force mode behavior

## Success Indicators

✅ All merge scenarios work correctly
✅ Protected fields (database, viewer) never overwritten without force
✅ Change detection accurately reports modifications
✅ Statistics calculation correct
✅ Deep merge handles arbitrary nesting levels
✅ No mutation of input configs
✅ >85% test coverage
✅ All tests pass

## Notes

- **Preserve List** (never overwrite): `database`, `project_root`, `viewer`, `last_sync_time`
- **Overwrite List** (replace by default): `status_metadata`, `status_flow`, `special_statuses`, `status_flow_version`
- Force mode overwrites everything except preserve list
- Deep copy is critical to prevent mutation bugs
- Handle nil values and type mismatches gracefully
- Use interface{} for maximum flexibility with JSON unmarshaling

## Estimated Breakdown

- ConfigMerger struct and setup: 20 min
- Merge() implementation: 45 min
- DeepMerge() implementation: 30 min
- DetectChanges() implementation: 30 min
- calculateStats() implementation: 20 min
- Helper functions (deepCopy, contains, etc.): 30 min
- Unit tests (11 test functions): 60-90 min
- **Total**: 3-4 hours
