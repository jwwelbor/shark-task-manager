---
task_key: T-E07-F24-004
feature_key: E07-F24
title: "Phase 4: Add CLI command for init update"
status: todo
agent: backend
priority: 7
estimated_hours: 2-3
dependencies:
  - T-E07-F24-001
  - T-E07-F24-002
  - T-E07-F24-003
related_docs:
  - ../technical-design.md
  - ../specifications/business-requirements.md
---

# Task: Phase 4 - CLI Command for Init Update

**Feature**: E07-F24 - Workflow Profile Support
**Phase**: 4 of 6
**Estimated Time**: 2-3 hours

## Objective

Add `shark init update` subcommand to the CLI that exposes workflow profile functionality with proper flag parsing, output formatting (human-readable and JSON), and integration testing.

## Files to Modify/Create

1. `internal/cli/commands/init.go` (modify)
   - Add `initUpdateCmd` subcommand
   - Add flags: `--workflow`, `--force`, `--dry-run`
   - Implement `runInitUpdate()` handler
   - Implement `displayUpdateResult()` for human output

2. `internal/cli/commands/init_update_test.go` (create)
   - Test basic profile application
   - Test advanced profile application
   - Test no-workflow flag (add missing fields)
   - Test dry-run mode
   - Test force mode
   - Test JSON output format
   - Test error handling

## Implementation Plan

### Step 1: Add Command Variables and Flags (`init.go`)

```go
// Add at top of file with other vars
var (
    workflowName  string
    updateForce   bool
    updateDryRun  bool
)

// Add initUpdateCmd definition
var initUpdateCmd = &cobra.Command{
    Use:   "update [flags]",
    Short: "Update Shark configuration",
    Long: `Update Shark configuration with workflow profiles or add missing fields.

Without --workflow flag, adds missing configuration fields while preserving
all existing values.

With --workflow flag, applies the specified workflow profile (basic or advanced).

Use --dry-run to preview changes before applying.`,
    Example: `  # Add missing fields only
  shark init update

  # Apply basic workflow (5 statuses)
  shark init update --workflow=basic

  # Apply advanced workflow (19 statuses)
  shark init update --workflow=advanced

  # Preview changes without applying
  shark init update --workflow=advanced --dry-run

  # Force overwrite existing status configurations
  shark init update --workflow=basic --force`,
    RunE: runInitUpdate,
}

// Register subcommand in init() function
func init() {
    cli.RootCmd.AddCommand(initCmd)
    initCmd.AddCommand(initUpdateCmd)

    // Existing init flags
    initCmd.Flags().BoolVar(&initNonInteractive, "non-interactive", false,
        "Skip all prompts (use defaults)")
    initCmd.Flags().BoolVar(&initForce, "force", false,
        "Overwrite existing config and templates")

    // Update subcommand flags
    initUpdateCmd.Flags().StringVar(&workflowName, "workflow", "",
        "Apply workflow profile (basic, advanced)")
    initUpdateCmd.Flags().BoolVar(&updateForce, "force", false,
        "Overwrite existing status configurations")
    initUpdateCmd.Flags().BoolVar(&updateDryRun, "dry-run", false,
        "Preview changes without applying")
}
```

### Step 2: Implement runInitUpdate Handler

```go
func runInitUpdate(cmd *cobra.Command, args []string) error {
    // 1. Determine config path
    configPath := ".sharkconfig.json"
    if configFlag := cmd.Flag("config"); configFlag != nil && configFlag.Value.String() != "" {
        configPath = configFlag.Value.String()
    }

    // 2. Create profile service
    service := init_pkg.NewProfileService(configPath)

    // 3. Build update options
    opts := init_pkg.UpdateOptions{
        ConfigPath:     configPath,
        WorkflowName:   workflowName,
        Force:          updateForce,
        DryRun:         updateDryRun,
        NonInteractive: cli.GlobalConfig.JSON,
        Verbose:        cli.GlobalConfig.Verbose,
    }

    // 4. Apply profile (or add missing fields if no workflow specified)
    result, err := service.ApplyProfile(opts)
    if err != nil {
        if cli.GlobalConfig.JSON {
            return cli.OutputJSON(map[string]interface{}{
                "success": false,
                "error":   err.Error(),
            })
        }
        return fmt.Errorf("failed to update config: %w", err)
    }

    // 5. Output results
    if cli.GlobalConfig.JSON {
        return cli.OutputJSON(result)
    }

    displayUpdateResult(result)
    return nil
}
```

### Step 3: Implement Display Function for Human Output

```go
func displayUpdateResult(result *init_pkg.UpdateResult) {
    // Header
    if result.DryRun {
        cli.Info("DRY RUN - No changes applied")
        fmt.Println()
    }

    // Success message
    if result.ProfileName != "" {
        cli.Success(fmt.Sprintf("Applied %s workflow profile", result.ProfileName))
    } else {
        cli.Success("Updated configuration")
    }
    fmt.Println()

    // Backup info
    if result.BackupPath != "" {
        fmt.Printf("✓ Backed up config to %s\n", result.BackupPath)
        fmt.Println()
    }

    // Changes summary
    changes := result.Changes
    if len(changes.Added) > 0 {
        fmt.Printf("  Added: %s\n", strings.Join(changes.Added, ", "))
    }
    if len(changes.Overwritten) > 0 {
        fmt.Printf("  Overwritten: %s\n", strings.Join(changes.Overwritten, ", "))
    }
    if len(changes.Preserved) > 0 {
        fmt.Printf("  Preserved: %s\n", strings.Join(changes.Preserved, ", "))
    }

    // Statistics
    if changes.Stats != nil {
        fmt.Println()
        fmt.Printf("  Statuses: %d added\n", changes.Stats.StatusesAdded)
        if changes.Stats.FlowsAdded > 0 {
            fmt.Printf("  Flows: %d added\n", changes.Stats.FlowsAdded)
        }
        if changes.Stats.GroupsAdded > 0 {
            fmt.Printf("  Groups: %d added\n", changes.Stats.GroupsAdded)
        }
        fmt.Printf("  Fields: %d preserved\n", changes.Stats.FieldsPreserved)
    }

    // Final status
    if !result.DryRun {
        fmt.Println()
        fmt.Printf("✓ Config updated: %s\n", result.ConfigPath)
    } else {
        fmt.Println()
        cli.Info("Run without --dry-run to apply these changes")
    }
}
```

### Step 4: Write Integration Tests (`init_update_test.go`)

```go
package commands

import (
    "encoding/json"
    "os"
    "path/filepath"
    "testing"

    init_pkg "github.com/jwwelbor/shark-task-manager/internal/init"
    "github.com/jwwelbor/shark-task-manager/internal/cli"
)

func TestInitUpdate_BasicProfile(t *testing.T) {
    // Setup: Create temp directory
    tmpDir := t.TempDir()
    configPath := filepath.Join(tmpDir, ".sharkconfig.json")

    // Create service
    service := init_pkg.NewProfileService(configPath)

    // Apply basic profile
    opts := init_pkg.UpdateOptions{
        ConfigPath:   configPath,
        WorkflowName: "basic",
        Force:        false,
        DryRun:       false,
    }

    result, err := service.ApplyProfile(opts)
    if err != nil {
        t.Fatalf("ApplyProfile failed: %v", err)
    }

    // Verify result
    if !result.Success {
        t.Error("Expected success=true")
    }
    if result.ProfileName != "basic" {
        t.Errorf("Expected profile_name=basic, got %s", result.ProfileName)
    }

    // Verify config file exists
    if _, err := os.Stat(configPath); os.IsNotExist(err) {
        t.Error("Config file was not created")
    }

    // Verify backup exists
    if result.BackupPath != "" {
        if _, err := os.Stat(result.BackupPath); os.IsNotExist(err) {
            t.Errorf("Backup file not found: %s", result.BackupPath)
        }
    }
}

func TestInitUpdate_AdvancedProfile(t *testing.T) {
    // Similar to basic but with advanced profile
}

func TestInitUpdate_NoWorkflowFlag(t *testing.T) {
    // Test adding missing fields without workflow flag
    tmpDir := t.TempDir()
    configPath := filepath.Join(tmpDir, ".sharkconfig.json")

    // Create partial config
    partialConfig := `{"database": {"backend": "local"}}`
    os.WriteFile(configPath, []byte(partialConfig), 0644)

    // Apply with no workflow
    service := init_pkg.NewProfileService(configPath)
    opts := init_pkg.UpdateOptions{
        ConfigPath:   configPath,
        WorkflowName: "", // Empty = add missing only
        Force:        false,
        DryRun:       false,
    }

    result, err := service.ApplyProfile(opts)
    if err != nil {
        t.Fatalf("ApplyProfile failed: %v", err)
    }

    // Verify database was preserved
    if !contains(result.Changes.Preserved, "database") {
        t.Error("Expected database to be preserved")
    }

    // Verify missing fields were added
    if len(result.Changes.Added) == 0 {
        t.Error("Expected some fields to be added")
    }
}

func TestInitUpdate_DryRun(t *testing.T) {
    tmpDir := t.TempDir()
    configPath := filepath.Join(tmpDir, ".sharkconfig.json")

    service := init_pkg.NewProfileService(configPath)
    opts := init_pkg.UpdateOptions{
        ConfigPath:   configPath,
        WorkflowName: "basic",
        Force:        false,
        DryRun:       true, // Dry run mode
    }

    result, err := service.ApplyProfile(opts)
    if err != nil {
        t.Fatalf("ApplyProfile failed: %v", err)
    }

    // Verify dry-run flag set
    if !result.DryRun {
        t.Error("Expected DryRun=true")
    }

    // Verify config file NOT created
    if _, err := os.Stat(configPath); err == nil {
        t.Error("Config file should not exist in dry-run mode")
    }

    // Verify changes were detected
    if result.Changes == nil {
        t.Error("Expected change report in dry-run")
    }
}

func TestInitUpdate_Force(t *testing.T) {
    // Test force mode overwrites existing
}

func TestInitUpdate_JSONOutput(t *testing.T) {
    tmpDir := t.TempDir()
    configPath := filepath.Join(tmpDir, ".sharkconfig.json")

    service := init_pkg.NewProfileService(configPath)
    opts := init_pkg.UpdateOptions{
        ConfigPath:   configPath,
        WorkflowName: "basic",
        Force:        false,
        DryRun:       false,
    }

    result, err := service.ApplyProfile(opts)
    if err != nil {
        t.Fatalf("ApplyProfile failed: %v", err)
    }

    // Marshal to JSON
    jsonData, err := json.Marshal(result)
    if err != nil {
        t.Fatalf("Failed to marshal JSON: %v", err)
    }

    // Verify valid JSON
    var parsed map[string]interface{}
    if err := json.Unmarshal(jsonData, &parsed); err != nil {
        t.Fatalf("Invalid JSON output: %v", err)
    }

    // Verify required fields
    if _, ok := parsed["success"]; !ok {
        t.Error("JSON missing 'success' field")
    }
    if _, ok := parsed["profile_name"]; !ok {
        t.Error("JSON missing 'profile_name' field")
    }
}

func TestInitUpdate_InvalidProfile(t *testing.T) {
    tmpDir := t.TempDir()
    configPath := filepath.Join(tmpDir, ".sharkconfig.json")

    service := init_pkg.NewProfileService(configPath)
    opts := init_pkg.UpdateOptions{
        ConfigPath:   configPath,
        WorkflowName: "invalid-profile",
        Force:        false,
        DryRun:       false,
    }

    _, err := service.ApplyProfile(opts)
    if err == nil {
        t.Error("Expected error for invalid profile")
    }
}

// Helper function
func contains(slice []string, item string) bool {
    for _, s := range slice {
        if s == item {
            return true
        }
    }
    return false
}
```

## Acceptance Criteria

- [x] **AC1**: `shark init update` adds missing fields without workflow flag
- [x] **AC2**: `shark init update --workflow=basic` applies basic profile
- [x] **AC3**: `shark init update --workflow=advanced` applies advanced profile
- [x] **AC4**: `shark init update --dry-run` shows preview without writing
- [x] **AC5**: `shark init update --force` overwrites existing configs
- [x] **AC6**: `--json` flag outputs valid JSON response
- [x] **AC7**: Error messages are clear and actionable
- [x] **AC8**: Help text (`shark init update --help`) is comprehensive
- [x] **AC9**: All integration tests pass
- [x] **AC10**: Command follows CLI patterns (global flags, output formatting)

## Test Plan

### Manual Testing

```bash
# Test 1: Add missing fields
shark init update
# Expected: Adds missing fields, preserves existing

# Test 2: Apply basic profile
shark init update --workflow=basic
# Expected: Applies 5-status workflow

# Test 3: Apply advanced profile
shark init update --workflow=advanced
# Expected: Applies 19-status workflow

# Test 4: Dry run
shark init update --workflow=basic --dry-run
# Expected: Shows preview, no changes applied

# Test 5: Force mode
shark init update --workflow=basic --force
# Expected: Overwrites existing status configs

# Test 6: JSON output
shark init update --workflow=basic --json
# Expected: Valid JSON response

# Test 7: Invalid profile
shark init update --workflow=invalid
# Expected: Error message listing valid profiles

# Test 8: Help text
shark init update --help
# Expected: Comprehensive usage documentation
```

### Integration Tests

```bash
# Run integration tests
go test -v ./internal/cli/commands -run TestInitUpdate

# Check test coverage
go test -cover ./internal/cli/commands -run TestInitUpdate
```

## Dependencies

**Requires**:
- T-E07-F24-001 (Phase 1: Data structures)
- T-E07-F24-002 (Phase 2: ConfigMerger)
- T-E07-F24-003 (Phase 3: ProfileService)

**Blocks**:
- T-E07-F24-005 (Phase 5: Documentation needs working command)

## Design References

- **Technical Design**: Section "Component Design - Command Handler" (lines 305-348)
- **CLI Implementation**: Section "File-by-File Implementation - init.go" (lines 687-836)
- **Output Formatting**: Section "displayUpdateResult" (lines 787-834)

## Success Indicators

✅ Command registered and accessible via `shark init update`
✅ All flags work correctly (--workflow, --force, --dry-run)
✅ Human-readable output clear and informative
✅ JSON output valid and complete
✅ Error messages actionable
✅ Help text comprehensive
✅ All integration tests pass
✅ Command follows Shark CLI patterns

## Notes

- **Command Path**: `shark init update` (subcommand of `init`)
- **Global Flags**: Inherits `--json`, `--verbose`, `--config` from root
- **Exit Codes**: Use standard Shark exit codes (0=success, 1=error)
- **Output Format**: Use `cli.Success()`, `cli.Error()`, `cli.Info()` helpers
- **JSON Mode**: When `--json` flag set, output JSON only (no human text)
- **Verbose Mode**: When `--verbose` flag set, show backup warnings and merge details
- **Dry-Run Hint**: Display hint to run without --dry-run to apply changes

## Example Outputs

### Human-Readable Output (Success)

```
Applied basic workflow profile

✓ Backed up config to .sharkconfig.json.backup.20260125-143022

  Added: status_metadata
  Preserved: database, viewer

  Statuses: 5 added
  Fields: 2 preserved

✓ Config updated: .sharkconfig.json
```

### Dry-Run Output

```
DRY RUN - No changes applied

Applied basic workflow profile

  Added: status_metadata
  Overwritten: color_enabled

  Statuses: 5 added
  Fields: 1 preserved

Run without --dry-run to apply these changes
```

### JSON Output

```json
{
  "success": true,
  "profile_name": "basic",
  "backup_path": ".sharkconfig.json.backup.20260125-143022",
  "changes": {
    "added": ["status_metadata"],
    "preserved": ["database", "viewer"],
    "overwritten": [],
    "stats": {
      "statuses_added": 5,
      "flows_added": 0,
      "groups_added": 0,
      "fields_preserved": 2
    }
  },
  "config_path": ".sharkconfig.json",
  "dry_run": false
}
```

### Error Output

```
Error: profile not found: invalid (available: basic, advanced)
```

## Estimated Breakdown

- Add command definition and flags: 20 min
- Implement runInitUpdate() handler: 30 min
- Implement displayUpdateResult() formatter: 30 min
- Integration tests (7 test functions): 45-60 min
- Manual testing and refinement: 15-20 min
- **Total**: 2-3 hours
