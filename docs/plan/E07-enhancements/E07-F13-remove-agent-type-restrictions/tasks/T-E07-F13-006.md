---
agent: backend
created_at: 2026-01-01T06:56:46Z
epic: E07
feature: E07-F13
key: T-E07-F13-006
priority: 8
status: in_refinement
task_key: T-E07-F13-006
title: Add comprehensive tests for custom agent types
related_docs:
  - docs/plan/E07-enhancements/E07-F13-remove-agent-type-restrictions/feature.md
---

# Task: Add comprehensive tests for custom agent types

## Goal

Create comprehensive test coverage for the custom agent type feature to ensure:
- Validation changes work correctly across all layers
- Template fallback behavior works as expected
- Database operations handle custom agent types properly
- CLI commands accept and display custom agent types correctly
- Backward compatibility is maintained with existing agent types
- Edge cases and error conditions are properly handled

This task covers testing at multiple layers: validation (models), task creation (taskcreation package), template rendering (templates package), database operations (repository layer), and CLI commands.

## Test Categories

### 1. Validation Layer Tests (`internal/models/validation_test.go`)

**Purpose**: Verify `ValidateAgentType()` accepts any non-empty string

**Test Cases**:
- [ ] **Valid Standard Agent Types**: Test all 6 standard types (frontend, backend, api, testing, devops, general) still pass validation
- [ ] **Valid Custom Agent Types**: Test custom types (architect, business-analyst, qa, tech-lead, product-manager, ux-designer, data-engineer, ml-specialist, security-auditor)
- [ ] **Edge Cases**:
  - Hyphenated agent types (data-engineer, ml-specialist)
  - Underscore-separated agent types (qa_engineer, tech_lead)
  - Mixed case agent types (DataEngineer, QA-Lead)
  - Single-character agent types (x, a)
  - Very long agent type names (50+ characters)
  - Special characters in agent types (agent@123, agent.dev)
- [ ] **Invalid Cases**:
  - Empty string should fail with clear error message
  - Whitespace-only string should fail
  - Null/nil value should fail (if applicable)
- [ ] **Error Messages**: Verify error messages are clear and actionable

**Example Test Structure**:
```go
func TestValidateAgentType_CustomTypes(t *testing.T) {
    tests := []struct {
        name      string
        agentType string
        wantErr   bool
        errMsg    string
    }{
        {"standard frontend", "frontend", false, ""},
        {"custom architect", "architect", false, ""},
        {"custom business-analyst", "business-analyst", false, ""},
        {"hyphenated data-engineer", "data-engineer", false, ""},
        {"empty string", "", true, "agent type cannot be empty"},
        {"whitespace only", "   ", true, "agent type cannot be empty"},
    }
    // ... test implementation
}
```

---

### 2. Task Creation Validator Tests (`internal/taskcreation/validator_test.go`)

**Purpose**: Verify task creation workflow handles custom agent types through validation pipeline

**Test Cases**:
- [ ] **Successful Creation with Custom Agent Types**:
  - Create task with `architect` agent type
  - Create task with `business-analyst` agent type
  - Create task with hyphenated custom type (data-engineer)
  - Verify task is created with exact agent type value (no normalization)
- [ ] **Backward Compatibility**:
  - Create task with standard agent types (frontend, backend, etc.)
  - Verify existing tests pass without modification
  - Verify behavior is identical to before feature changes
- [ ] **Agent Type Storage**:
  - Verify custom agent type is stored in `AgentType` field
  - Verify agent type is preserved exactly as entered
  - Verify case is preserved (no lowercase conversion)
- [ ] **Integration with Dependencies**:
  - Create task with custom agent type and dependencies
  - Verify both agent type and dependencies are handled correctly
- [ ] **Error Handling**:
  - Attempt to create task with empty agent type
  - Verify appropriate error is returned
  - Verify error message guides user to provide valid value

**Example Test Structure**:
```go
func TestValidator_CustomAgentType_Success(t *testing.T) {
    // Setup: Create epic and feature
    // Test: Create task with custom agent type "architect"
    // Verify: Task created with agent_type="architect"
    // Verify: Agent type is stored correctly in database
}

func TestValidator_CustomAgentType_BackwardCompatibility(t *testing.T) {
    // Test all 6 standard agent types still work
    // Verify behavior is unchanged from before feature
}
```

**Database Verification**:
- Query database to verify agent_type column contains custom value
- Use `internal/test/testdb.go` for database setup
- Clean up test data before and after test

---

### 3. Template Renderer Tests (`internal/templates/renderer_test.go`)

**Purpose**: Verify template fallback behavior for custom agent types

**Test Cases**:
- [ ] **Template Fallback for Custom Agent Types**:
  - Render task with `architect` agent type (no specific template)
  - Verify fallback to `general` template occurs
  - Verify no error is thrown during fallback
  - Verify rendered content is valid markdown
- [ ] **Standard Agent Type Templates Still Work**:
  - Render task with `frontend` agent type
  - Verify frontend-specific template is used (not fallback)
  - Render task with `backend` agent type
  - Verify backend-specific template is used
- [ ] **Template Content Verification**:
  - Verify custom agent type appears in rendered task file
  - Verify task metadata (key, title, epic, feature) is correct
  - Verify frontmatter YAML is valid
  - Verify template sections are present (Goal, Implementation, Acceptance Criteria)
- [ ] **Multiple Custom Agent Types**:
  - Test multiple custom types in sequence (architect, qa, ux-designer)
  - Verify each uses fallback template correctly
  - Verify no state pollution between renders
- [ ] **Edge Cases**:
  - Render with very long custom agent type name
  - Render with hyphenated agent type
  - Render with special characters in agent type

**Example Test Structure**:
```go
func TestRenderer_CustomAgentType_Fallback(t *testing.T) {
    loader := NewLoader("")
    renderer := NewRenderer(loader)

    data := TemplateData{
        Key:       "T-E10-F01-001",
        Title:     "Design API Architecture",
        AgentType: "architect", // Custom type, no specific template
    }

    result, err := renderer.Render("architect", data)

    // Verify no error
    require.NoError(t, err)

    // Verify fallback occurred (general template used)
    assert.Contains(t, result, "agent: architect")

    // Verify valid markdown structure
    assert.Contains(t, result, "# Task:")
    assert.Contains(t, result, "## Goal")
}

func TestRenderer_StandardAgentType_StillWorks(t *testing.T) {
    // Verify frontend template is still used for frontend tasks
    // Verify backend template is still used for backend tasks
}
```

**Verification Points**:
- No validation error occurs for custom agent type
- Fallback to general template is seamless
- Rendered content contains custom agent type value
- Standard templates are still selected for standard agent types

---

### 4. Database Integration Tests (`internal/repository/task_repository_test.go`)

**Purpose**: Verify database correctly stores and retrieves custom agent types

**Test Cases**:
- [ ] **Create Task with Custom Agent Type**:
  - Create task with `architect` agent type
  - Query database to verify agent_type column value
  - Verify value is stored exactly as provided
- [ ] **Retrieve Task with Custom Agent Type**:
  - Create task with custom agent type
  - Retrieve by key using `GetByKey()`
  - Verify retrieved task has correct agent type
  - Verify no data loss or transformation
- [ ] **Filter Tasks by Custom Agent Type**:
  - Create multiple tasks with different custom agent types
  - Use `task list --agent=architect` filtering
  - Verify only tasks with matching agent type are returned
  - Test case sensitivity in filtering
- [ ] **Update Task Agent Type**:
  - Create task with standard agent type
  - Update to custom agent type
  - Verify update succeeds
  - Verify database reflects new value
- [ ] **Mixed Agent Types Query**:
  - Create tasks with both standard and custom agent types
  - List all tasks
  - Verify both types are returned correctly
  - Verify no corruption or mixing of values
- [ ] **Agent Type Persistence**:
  - Create task with custom agent type
  - Close and reopen database connection
  - Query task again
  - Verify agent type persists correctly across connections

**Example Test Structure**:
```go
func TestTaskRepository_CreateWithCustomAgentType(t *testing.T) {
    ctx := context.Background()
    database := test.GetTestDB()
    db := NewDB(database)
    repo := NewTaskRepository(db)

    // Clean up
    _, _ = database.ExecContext(ctx, "DELETE FROM tasks WHERE key = 'TEST-E07-F13-001'")

    // Seed test data
    epicID, featureID := test.SeedTestData()

    // Create task with custom agent type
    task := &models.Task{
        Key:       "TEST-E07-F13-001",
        Title:     "Test Task",
        AgentType: ptr("architect"), // Custom agent type
        EpicID:    epicID,
        FeatureID: featureID,
    }

    err := repo.Create(ctx, task)
    require.NoError(t, err)

    // Retrieve and verify
    retrieved, err := repo.GetByKey(ctx, "TEST-E07-F13-001")
    require.NoError(t, err)
    assert.Equal(t, "architect", *retrieved.AgentType)

    // Cleanup
    defer database.ExecContext(ctx, "DELETE FROM tasks WHERE id = ?", task.ID)
}

func TestTaskRepository_FilterByCustomAgentType(t *testing.T) {
    // Create tasks with architect, business-analyst, qa
    // Filter by --agent=architect
    // Verify only architect tasks returned
}
```

**Database Cleanup**:
- Use `DELETE FROM tasks WHERE key LIKE 'TEST-%'` pattern
- Clean before test to avoid pollution
- Use `defer` for cleanup after test
- Follow patterns from `.claude/rules/testing/repository-tests.md`

---

### 5. CLI Command Tests (`internal/cli/commands/task_test.go`)

**Purpose**: Verify CLI commands accept and display custom agent types correctly (USING MOCKS, NOT DATABASE)

**Test Cases**:
- [ ] **Task Create Command**:
  - Parse `--agent=architect` flag
  - Verify agent type is passed to validator
  - Verify success message includes custom agent type
  - Test with various custom agent type values
- [ ] **Task List Command**:
  - Mock repository to return tasks with custom agent types
  - Verify tasks are displayed with correct agent type
  - Verify filtering by `--agent=architect` works
  - Test JSON output format includes custom agent type
- [ ] **Task Get Command**:
  - Mock repository to return task with custom agent type
  - Verify task details display custom agent type correctly
  - Verify both table and JSON output formats work
- [ ] **Task Update Command** (if applicable):
  - Update task to use custom agent type
  - Verify command accepts custom agent type value
  - Verify success message is appropriate
- [ ] **Filtering Logic**:
  - Test `--agent=architect` flag parsing
  - Verify filter is passed correctly to repository
  - Test case sensitivity in filtering
- [ ] **Error Messages**:
  - Attempt to create task with empty agent type
  - Verify clear, actionable error message
  - Verify exit code is appropriate (exit code 3 for invalid state)

**Example Test Structure**:
```go
func TestTaskCreateCommand_CustomAgentType(t *testing.T) {
    // Create mock repository
    mockRepo := &MockTaskRepository{
        CreateFunc: func(ctx context.Context, task *models.Task) error {
            // Verify agent type is "architect"
            assert.Equal(t, "architect", *task.AgentType)
            task.ID = 123
            return nil
        },
    }

    // Test command logic (not actual cobra execution)
    // Parse args: ["E10", "F01", "Design Architecture", "--agent=architect"]
    // Verify agent type is extracted and passed to repository
}

func TestTaskListCommand_CustomAgentTypeDisplay(t *testing.T) {
    // Mock repository to return tasks with custom agent types
    mockRepo := &MockTaskRepository{
        ListFunc: func(ctx context.Context, filters map[string]interface{}) ([]*models.Task, error) {
            return []*models.Task{
                {Key: "E10-F01-001", Title: "Task 1", AgentType: ptr("architect")},
                {Key: "E10-F01-002", Title: "Task 2", AgentType: ptr("business-analyst")},
            }, nil
        },
    }

    // Test list command logic
    // Verify output includes custom agent types
    // Test both table and JSON output formats
}
```

**Mock Usage**:
- NEVER use real database in CLI tests (per `.claude/rules/testing/cli-tests.md`)
- Create mock repository interfaces
- Inject mocks into command handlers
- Verify command behavior without database

---

### 6. Integration Tests (End-to-End Workflow)

**Purpose**: Verify complete workflow from task creation to retrieval with custom agent types

**Test Cases**:
- [ ] **Full Workflow Test**:
  - Create epic
  - Create feature
  - Create task with custom agent type `architect`
  - Retrieve task by key
  - Verify agent type matches throughout
  - List tasks filtered by custom agent type
  - Verify task appears in filtered list
- [ ] **Multi-Agent Workflow**:
  - Create tasks with multiple custom agent types (architect, business-analyst, qa, ux-designer)
  - Verify each task has correct agent type
  - Filter by each agent type
  - Verify filtering works correctly for each
- [ ] **Backward Compatibility Workflow**:
  - Create tasks with standard agent types
  - Create tasks with custom agent types
  - List all tasks
  - Verify both types coexist correctly
  - Verify no conflicts or data corruption
- [ ] **Template to Database Workflow**:
  - Create task with custom agent type
  - Verify task file is created with correct template
  - Verify database entry has correct agent type
  - Sync filesystem to database
  - Verify agent type remains correct after sync

**Example Test Structure**:
```go
func TestEndToEnd_CustomAgentType_Workflow(t *testing.T) {
    ctx := context.Background()
    database := test.GetTestDB()
    db := NewDB(database)

    // Clean up
    _, _ = database.ExecContext(ctx, "DELETE FROM tasks WHERE key LIKE 'TEST-%'")

    // Create epic and feature
    epicRepo := NewEpicRepository(db)
    featureRepo := NewFeatureRepository(db)
    taskRepo := NewTaskRepository(db)

    epic := &models.Epic{Key: "E99", Title: "Test Epic"}
    _ = epicRepo.Create(ctx, epic)
    defer database.ExecContext(ctx, "DELETE FROM epics WHERE id = ?", epic.ID)

    feature := &models.Feature{Key: "E99-F01", Title: "Test Feature", EpicID: epic.ID}
    _ = featureRepo.Create(ctx, feature)
    defer database.ExecContext(ctx, "DELETE FROM features WHERE id = ?", feature.ID)

    // Create task with custom agent type
    task := &models.Task{
        Key:       "TEST-E99-F01-001",
        Title:     "Design Architecture",
        AgentType: ptr("architect"),
        EpicID:    epic.ID,
        FeatureID: feature.ID,
    }

    err := taskRepo.Create(ctx, task)
    require.NoError(t, err)
    defer database.ExecContext(ctx, "DELETE FROM tasks WHERE id = ?", task.ID)

    // Retrieve task
    retrieved, err := taskRepo.GetByKey(ctx, "TEST-E99-F01-001")
    require.NoError(t, err)
    assert.Equal(t, "architect", *retrieved.AgentType)

    // Filter tasks by custom agent type
    tasks, err := taskRepo.ListByAgent(ctx, "architect")
    require.NoError(t, err)
    assert.Len(t, tasks, 1)
    assert.Equal(t, "architect", *tasks[0].AgentType)
}
```

---

## Performance Tests

**Purpose**: Ensure validation changes do not degrade performance

**Test Cases**:
- [ ] **Validation Performance**:
  - Benchmark `ValidateAgentType()` before and after changes
  - Verify validation time difference is <1ms (per REQ-NF-002)
  - Test with 1000 iterations
- [ ] **Task Creation Performance**:
  - Benchmark task creation with custom agent types
  - Compare to task creation with standard agent types
  - Verify no performance degradation
- [ ] **Query Performance**:
  - Benchmark task list queries filtered by custom agent type
  - Verify query performance is equivalent to standard agent type filtering
  - Test with large datasets (1000+ tasks)

**Example Benchmark**:
```go
func BenchmarkValidateAgentType_Standard(b *testing.B) {
    for i := 0; i < b.N; i++ {
        _ = ValidateAgentType("backend")
    }
}

func BenchmarkValidateAgentType_Custom(b *testing.B) {
    for i := 0; i < b.N; i++ {
        _ = ValidateAgentType("architect")
    }
}
```

---

## Test Data Requirements

**Standard Agent Types** (for backward compatibility tests):
- `frontend`
- `backend`
- `api`
- `testing`
- `devops`
- `general`

**Custom Agent Types** (for new feature tests):
- `architect`
- `business-analyst`
- `qa`
- `tech-lead`
- `product-manager`
- `ux-designer`
- `data-engineer`
- `ml-specialist`
- `security-auditor`

**Edge Case Agent Types**:
- Hyphenated: `data-engineer`, `ml-specialist`, `security-auditor`
- Underscore: `qa_engineer`, `tech_lead`, `product_manager`
- Mixed case: `DataEngineer`, `BusinessAnalyst`, `QA-Lead`
- Single character: `x`, `a`
- Long names: `very-long-custom-agent-type-name-for-edge-case-testing`

---

## Test Success Criteria

- [ ] **100% Test Coverage**: All modified functions have comprehensive tests
- [ ] **All Tests Pass**: No failing tests in any test suite
- [ ] **Backward Compatibility**: All existing tests pass without modification
- [ ] **Performance**: Validation performance difference <1ms (REQ-NF-002)
- [ ] **No Regressions**: Standard agent types work exactly as before
- [ ] **Clear Error Messages**: All error cases have clear, actionable error messages
- [ ] **Mock Usage**: All CLI tests use mocks, not real database
- [ ] **Database Cleanup**: All repository tests clean up test data

---

## Test Organization

**Files to Create/Update**:
1. `internal/models/validation_test.go` - Add custom agent type validation tests
2. `internal/taskcreation/validator_test.go` - Add custom agent type workflow tests
3. `internal/templates/renderer_test.go` - Add template fallback tests
4. `internal/repository/task_repository_test.go` - Add database integration tests
5. `internal/cli/commands/task_test.go` - Add CLI command tests (with mocks)
6. `internal/integration/custom_agent_type_test.go` - New file for end-to-end tests

**Test Execution Order**:
1. Unit tests (validation, models)
2. Service layer tests (taskcreation, templates)
3. Repository tests (database integration)
4. CLI tests (command behavior with mocks)
5. Integration tests (end-to-end workflows)
6. Performance benchmarks

---

## Acceptance Criteria

- [ ] All 6 test categories have comprehensive test coverage
- [ ] Tests verify both standard and custom agent types work correctly
- [ ] Template fallback behavior is tested for unknown agent types
- [ ] Database correctly stores and retrieves custom agent types
- [ ] CLI commands accept, display, and filter custom agent types
- [ ] Backward compatibility is verified with existing agent types
- [ ] Edge cases are tested (empty, whitespace, special characters)
- [ ] Performance tests verify no degradation (<1ms difference)
- [ ] All tests follow project testing patterns (mocks for CLI, cleanup for repository)
- [ ] Test coverage report shows >90% coverage for modified code
- [ ] All tests pass in CI/CD pipeline

---

## Testing Patterns Reference

**Repository Tests**:
- Use real database via `test.GetTestDB()`
- Clean up BEFORE test: `DELETE FROM tasks WHERE key LIKE 'TEST-%'`
- Use `defer` for cleanup AFTER test
- Follow `.claude/rules/testing/repository-tests.md`

**CLI Tests**:
- NEVER use real database
- Create mock repository interfaces
- Test command logic in isolation
- Follow `.claude/rules/testing/cli-tests.md`

**Validation Tests**:
- Pure logic tests, no database
- Table-driven test structure
- Cover all edge cases
- Clear error message verification

---

## Related Documentation

- Feature PRD: `docs/plan/E07-enhancements/E07-F13-remove-agent-type-restrictions/feature.md`
- Testing Architecture: `.claude/rules/testing/architecture.md`
- Repository Test Patterns: `.claude/rules/testing/repository-tests.md`
- CLI Test Patterns: `.claude/rules/testing/cli-tests.md`
- Go Testing Patterns: `.claude/rules/go/patterns.md`

---

## Notes

- Follow existing test patterns in the codebase
- Use table-driven tests for multiple test cases
- Verify error messages are clear and actionable
- Test both happy path and error cases
- Include performance benchmarks to verify REQ-NF-002 (no performance degradation)
- Ensure backward compatibility by testing all standard agent types still work
