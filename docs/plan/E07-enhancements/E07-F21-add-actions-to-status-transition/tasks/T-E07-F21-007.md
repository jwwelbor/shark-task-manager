
---
key: T-E07-F21-007
title: Add orchestrator action to task start command
epic: E07
feature: E07-F21
agent: backend
status: todo
priority: 7
depends_on: ["T-E07-F21-006"]
created_at: 2026-01-15T01:52:56Z
---

# Task: Add orchestrator action to task start command

## Goal

Enhance the `shark task start` command to return `orchestrator_action` metadata when transitioning a task from `todo` to `in_progress`. This enables AI Agent Orchestrators to receive execution instructions for the newly started task in a single API call.

**Context**: This task applies the response enhancement pattern established in T-E07-F21-006 specifically to the `task start` command, which is the primary entry point for agents beginning work.

**User Story**: As an orchestrator developer, when an agent is assigned a task and runs `shark task start`, I want to receive the orchestrator action for the `in_progress` status so that I can immediately understand what work to perform without making a separate query (Story 1, Story 2).

**Impact**: Streamlines agent startup workflow, reduces API calls, and provides complete context (task data + work instructions) in a single response.

## Command Behavior Changes

### Current Behavior

**Command**:
```bash
shark task start E01-F03-002 --json
```

**Response**:
```json
{
  "id": 123,
  "key": "T-E01-F03-002",
  "status": "in_progress",
  "title": "Implement JWT validation",
  "agent_type": "backend",
  "started_at": "2026-01-15T14:30:00Z"
}
```

### Enhanced Behavior

**Command**:
```bash
shark task start E01-F03-002 --json
```

**Response** (with orchestrator action):
```json
{
  "id": 123,
  "key": "T-E01-F03-002",
  "status": "in_progress",
  "title": "Implement JWT validation",
  "agent_type": "backend",
  "started_at": "2026-01-15T14:30:00Z",
  "orchestrator_action": {
    "action": "spawn_agent",
    "agent_type": "backend",
    "skills": ["implementation", "testing", "api-development"],
    "instruction": "Launch a backend agent to implement task T-E01-F03-002. Review task requirements, write implementation code, and create unit tests."
  }
}
```

**Backward Compatibility**: If no orchestrator action is configured for `in_progress` status, the `orchestrator_action` field is omitted entirely (not null):

```json
{
  "id": 123,
  "key": "T-E01-F03-002",
  "status": "in_progress",
  "title": "Implement JWT validation",
  "agent_type": "backend",
  "started_at": "2026-01-15T14:30:00Z"
  // NO orchestrator_action field
}
```

### Human-Readable Output

**With orchestrator action**:
```
Task T-E01-F03-002 started successfully
Status: todo → in_progress

Next Action:
  Type: spawn_agent
  Agent: backend
  Skills: implementation, testing, api-development

Instruction: Launch a backend agent to implement task T-E01-F03-002. Review task requirements...
```

**Without orchestrator action**:
```
Task T-E01-F03-002 started successfully
Status: todo → in_progress

Next Action: None configured
```

## Response Format Specification

### JSON Output Structure

Follow the pattern from T-E07-F21-006:

**OrchestratorAction Object**:
```json
{
  "action": "spawn_agent" | "pause" | "wait_for_triage" | "archive",
  "agent_type": "string (required if action=spawn_agent)",
  "skills": ["array", "of", "strings (required if action=spawn_agent)"],
  "instruction": "string (template with {task_id} populated)"
}
```

**Complete Task Start Response**:
```json
{
  "id": 123,
  "key": "T-E01-F03-002",
  "slug": "implement-jwt-validation",
  "feature_id": 45,
  "epic_id": 7,
  "title": "Implement JWT validation",
  "description": "Add JWT token validation middleware to API",
  "status": "in_progress",
  "priority": 5,
  "agent_type": "backend",
  "depends_on": ["T-E01-F03-001"],
  "file_path": "docs/plan/E01-platform/E01-F03-auth/tasks/T-E01-F03-002.md",
  "created_at": "2026-01-15T10:00:00Z",
  "updated_at": "2026-01-15T14:30:00Z",
  "started_at": "2026-01-15T14:30:00Z",
  "orchestrator_action": {
    "action": "spawn_agent",
    "agent_type": "backend",
    "skills": ["implementation", "testing", "api-development"],
    "instruction": "Launch a backend agent to implement task T-E01-F03-002. Review task requirements, write implementation code, and create unit tests."
  }
}
```

### Field Semantics

- **orchestrator_action**: Present if action is configured for `in_progress` status, omitted otherwise
- **started_at**: Timestamp when task was started (existing field)
- **status**: Always `in_progress` after successful start
- **agent_type**: Task's assigned agent type (may differ from orchestrator_action.agent_type)

## Implementation Details

### CLI Command Changes

**Location**: `internal/cli/commands/task.go`

**Method**: `runTaskStart(cmd *cobra.Command, args []string)`

**Current Implementation**:
```go
func runTaskStart(cmd *cobra.Command, args []string) error {
    // Parse task key
    taskKey := args[0]

    // Get repository and update status
    repo := getTaskRepository()
    task, err := repo.UpdateStatus(ctx, taskKey, "in_progress")
    if err != nil {
        return err
    }

    // Output task
    return outputTask(task)
}
```

**Enhanced Implementation**:
```go
func runTaskStart(cmd *cobra.Command, args []string) error {
    // Parse task key
    taskKey := args[0]

    // Get repository and update status (returns task + orchestrator_action)
    repo := getTaskRepository()
    task, action, err := repo.UpdateStatus(ctx, taskKey, "in_progress")
    if err != nil {
        return err
    }

    // Output task with orchestrator_action
    return outputTaskWithAction(task, action)
}
```

**Key Changes**:
1. **Repository call**: Now returns `(task, action, error)` instead of `(task, error)`
2. **Output function**: Uses `outputTaskWithAction` to include orchestrator_action in response
3. **Backward compatibility**: If `action` is nil, field is omitted from JSON

### Repository Integration

**Dependency**: T-E07-F21-006 already implemented the repository layer changes:
- `UpdateStatus` returns `(Task, OrchestratorAction, error)`
- `getOrchestratorAction` fetches action from config service
- Template variables are populated (e.g., `{task_id}`)

**Task Start Specifics**:
- Status transition: `todo` → `in_progress`
- Orchestrator action queried for `in_progress` status
- Template populated with task key (e.g., `T-E01-F03-002`)

### Output Helper Functions

**New Function**: `outputTaskWithAction`

```go
func outputTaskWithAction(task *models.Task, action *models.OrchestratorAction) error {
    if cli.GlobalConfig.JSON {
        // JSON output with orchestrator_action (omitted if nil)
        response := struct {
            *models.Task
            OrchestratorAction *models.OrchestratorAction `json:"orchestrator_action,omitempty"`
        }{
            Task:               task,
            OrchestratorAction: action,
        }
        return cli.OutputJSON(response)
    }

    // Human-readable output
    displayTaskUpdate(task)
    displayOrchestratorAction(action) // From T-E07-F21-006
    return nil
}
```

### Error Handling

Follow T-E07-F21-006 pattern:

| Scenario | Handling | Response |
|----------|----------|----------|
| Status has no orchestrator_action | Return nil action, omit from response | Success |
| Config service unavailable | Log warning, return nil action | Success |
| Template variable missing | Use template as-is (unpopulated) | Success |
| Invalid status transition | Fail with error | Fail |
| Task not found | Fail with error | Fail |

**Logging**:
- **Debug**: "Starting task T-E01-F03-002: todo → in_progress"
- **Debug**: "Retrieved orchestrator action for status in_progress"
- **Warn**: "Failed to get orchestrator action: config service error"

## Acceptance Criteria

**From User Story 1 & 2**:
- [ ] `shark task start` returns `orchestrator_action` object when configured for `in_progress` status
- [ ] Action includes `action`, `agent_type`, `skills`, and `instruction` fields (when action type is spawn_agent)
- [ ] Template variables (e.g., `{task_id}`) are populated in instructions
- [ ] Response is backward compatible (missing actions don't break existing code)
- [ ] JSON output format matches specification above

**Command-Specific Criteria**:
- [ ] Task status transitions from `todo` to `in_progress` successfully
- [ ] Orchestrator action is queried for `in_progress` status (not `todo`)
- [ ] `started_at` timestamp is set correctly
- [ ] Human-readable output displays action summary clearly
- [ ] Missing orchestrator_action results in field omission (not null, not error)
- [ ] Works with existing Shark installations (backward compatible)

**Error Handling**:
- [ ] Cannot start task already in progress (existing validation)
- [ ] Cannot start task with incomplete dependencies (existing validation)
- [ ] Config service errors are handled gracefully (log warning, continue)
- [ ] Template population errors are handled gracefully (return unpopulated template)

**Performance**:
- [ ] Performance impact <10ms additional latency per start
- [ ] No regression in existing start command performance

## Testing Requirements

### Unit Tests

**CLI Command Tests** (`internal/cli/commands/task_test.go`):
- [ ] `TestTaskStart_WithOrchestratorAction` - action included in response
- [ ] `TestTaskStart_WithoutOrchestratorAction` - field omitted from response
- [ ] `TestTaskStart_JSONOutput` - JSON serialization with omitempty
- [ ] `TestTaskStart_HumanOutput` - action summary displayed
- [ ] `TestTaskStart_TemplatePopulation` - {task_id} replaced with actual key
- [ ] `TestTaskStart_ConfigServiceError` - graceful handling, warning logged
- [ ] `TestTaskStart_InvalidTransition` - error when task not in todo status
- [ ] `TestTaskStart_DependencyBlocked` - error when dependencies incomplete

**Repository Integration** (covered by T-E07-F21-006):
- UpdateStatus returns orchestrator_action for in_progress status
- Template population works correctly
- Config service integration functional

### Integration Tests

**End-to-End Workflow**:
- [ ] Create task in todo status
- [ ] Run `shark task start T-E01-F03-002 --json`
- [ ] Verify status changed to in_progress
- [ ] Verify orchestrator_action in response
- [ ] Verify instruction includes task ID (T-E01-F03-002)
- [ ] Verify agent_type matches config for in_progress status

**Config Service Integration**:
- [ ] Config loaded with orchestrator_action for in_progress
- [ ] Repository queries config service for in_progress status
- [ ] Action retrieved matches config definition
- [ ] Missing actions return nil without errors

**Template Engine Integration**:
- [ ] Template {task_id} replaced with actual task key
- [ ] Template syntax errors handled gracefully

**Backward Compatibility**:
- [ ] Shark installations without orchestrator_action work unchanged
- [ ] Existing orchestrators ignore new field without breaking
- [ ] Response format compatible with existing parsers

### Scenario Tests

**Scenario 1: Standard Agent Workflow**
```bash
# Orchestrator assigns task to agent
shark task next --agent=backend --json
# Returns: T-E01-F03-002

# Agent starts task
shark task start T-E01-F03-002 --json
# Returns: orchestrator_action with spawn_agent instruction

# Agent uses instruction to begin work
# ...
```

**Scenario 2: No Orchestrator Action Configured**
```bash
# Legacy config without orchestrator_action for in_progress
shark task start T-E01-F03-002 --json
# Returns: task without orchestrator_action field (backward compatible)
```

**Scenario 3: Human User Starts Task**
```bash
# Human user starts task without --json flag
shark task start T-E01-F03-002
# Displays: "Task started successfully" with action summary
```

## Usage Examples

### Example 1: Agent Workflow

**Orchestrator perspective**:
```python
# Assign task to agent
next_task = shark.task_next(agent="backend")
# Returns: {"key": "T-E01-F03-002", ...}

# Start task and get work instructions
response = shark.task_start(next_task["key"])
# Returns: {
#   "key": "T-E01-F03-002",
#   "status": "in_progress",
#   "orchestrator_action": {
#     "action": "spawn_agent",
#     "agent_type": "backend",
#     "skills": ["implementation", "testing"],
#     "instruction": "Launch a backend agent to implement task T-E01-F03-002..."
#   }
# }

# Spawn agent with instruction
agent = spawn_agent(
    agent_type=response["orchestrator_action"]["agent_type"],
    skills=response["orchestrator_action"]["skills"],
    instruction=response["orchestrator_action"]["instruction"]
)
```

### Example 2: Manual Task Start

**Human user**:
```bash
shark task start E01-F03-002
```

**Output**:
```
Task T-E01-F03-002 started successfully
Status: todo → in_progress
Started: 2026-01-15T14:30:00Z

Next Action:
  Type: spawn_agent
  Agent: backend
  Skills: implementation, testing, api-development

Instruction: Launch a backend agent to implement task T-E01-F03-002. Review task requirements, write implementation code, and create unit tests.
```

### Example 3: CI/CD Pipeline

**Automated workflow**:
```bash
# CI/CD pipeline starts task automatically
TASK_KEY=$(shark task next --agent=backend --json | jq -r '.key')
RESPONSE=$(shark task start $TASK_KEY --json)

# Extract orchestrator action
ACTION_TYPE=$(echo $RESPONSE | jq -r '.orchestrator_action.action')
AGENT_TYPE=$(echo $RESPONSE | jq -r '.orchestrator_action.agent_type')
INSTRUCTION=$(echo $RESPONSE | jq -r '.orchestrator_action.instruction')

# Spawn agent based on action
if [ "$ACTION_TYPE" = "spawn_agent" ]; then
  ./spawn-agent.sh --type=$AGENT_TYPE --instruction="$INSTRUCTION"
fi
```

## Notes

### Design Decisions

**Why return orchestrator action on start?**
- Task start is the primary entry point for agent work
- Provides complete context in single API call (task + instructions)
- Enables orchestrators to immediately understand what work to perform
- Follows pattern from T-E07-F21-006 (consistent across all transitions)

**Why query for in_progress status, not todo?**
- Orchestrator action is for the NEW status after transition
- Agent needs instructions for what to do while "in_progress"
- "todo" status represents waiting state, no active work

**Why omit field instead of returning null?**
- Consistent with T-E07-F21-006 design
- More idiomatic JSON representation
- Easier for orchestrators to detect: `if (action)` vs `if (action !== null)`
- Reduces response payload size

### Dependencies

**MUST complete before starting**:
- T-E07-F21-006: Response enhancement pattern established
  - Repository layer returns (Task, OrchestratorAction, error)
  - Helper functions for action retrieval and display
  - Template population logic

**Builds on**:
- T-E07-F21-001: OrchestratorAction model exists
- T-E07-F21-002: Template engine available
- T-E07-F21-004: Config service loaded

### Implementation Checklist

**Phase 1: CLI Command Update** (2 hours):
- [ ] Update runTaskStart to call UpdateStatus (already returns action)
- [ ] Implement outputTaskWithAction helper
- [ ] Add JSON serialization with omitempty
- [ ] Add human-readable display for action

**Phase 2: Unit Tests** (2 hours):
- [ ] Test action included when configured
- [ ] Test field omitted when not configured
- [ ] Test JSON output format
- [ ] Test human-readable display
- [ ] Test error scenarios

**Phase 3: Integration Tests** (2 hours):
- [ ] End-to-end workflow test
- [ ] Config service integration test
- [ ] Backward compatibility test
- [ ] Template population test

**Phase 4: Documentation** (1 hour):
- [ ] Update CLI help text for task start
- [ ] Add examples to documentation
- [ ] Update API reference

### Assumptions

1. **T-E07-F21-006 is complete** - repository layer already returns orchestrator_action
2. **Config service has in_progress action** - or gracefully handles missing action
3. **Template engine supports {task_id}** - dependency on T-E07-F21-002
4. **Backward compatibility critical** - existing start command behavior preserved
5. **Performance budget: 10ms** - same as T-E07-F21-006
