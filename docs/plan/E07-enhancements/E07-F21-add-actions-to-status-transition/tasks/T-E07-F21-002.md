
---
key: T-E07-F21-002
title: Create template rendering engine
epic: E07
feature: E07-F21
agent: backend
status: todo
priority: 9
created_at: 2026-01-15T01:52:40Z
---

# Task: Create template rendering engine

## Goal

Create a simple, extensible template rendering engine for the `instruction_template` field in orchestrator actions. The engine will support variable substitution in instruction templates, starting with `{task_id}` placeholder and designed for future expansion to additional variables.

**Purpose**: When Shark returns orchestrator actions in status transition responses, the instruction templates need variable substitution (e.g., replacing `{task_id}` with actual task ID "T-E07-F21-002").

**Scope**: Simple string replacement for v1; extensible architecture for future template variables.

## Template Syntax Specification

### Phase 1 (This Task): Basic Variable Substitution

**Supported Variables**:
- `{task_id}` - Replaced with the actual task key (e.g., "T-E07-F21-002")

**Syntax Rules**:
- Variables are case-sensitive
- Variables use curly braces: `{variable_name}`
- Unknown variables are left as-is (no error thrown)
- Empty templates return empty string

**Examples**:
```
Template: "Launch developer agent to implement task {task_id}"
Task ID: "T-E07-F21-002"
Result: "Launch developer agent to implement task T-E07-F21-002"

Template: "Task {task_id} is blocked. Reason: {block_reason}"
Task ID: "T-E01-F03-001"
Result: "Task T-E01-F03-001 is blocked. Reason: {block_reason}"
(Note: {block_reason} left as-is since not supported in Phase 1)
```

### Future Extension (Out of Scope for This Task)

**Phase 2 Variables** (reference for extensible design):
- `{epic_id}`, `{feature_id}`, `{task_title}`, `{priority}`
- `{status}`, `{previous_status}`
- Custom agent-specific variables

## API Design

### Core Interface

```go
package template

// TemplateRenderer renders instruction templates with variable substitution
type TemplateRenderer interface {
    // Render replaces variables in template with values from context
    Render(template string, context map[string]string) string
}

// NewRenderer creates a new template renderer
func NewRenderer() TemplateRenderer {
    return &simpleRenderer{}
}
```

### Usage Example

```go
renderer := template.NewRenderer()

context := map[string]string{
    "task_id": "T-E07-F21-002",
}

template := "Launch developer agent to implement task {task_id}. Write tests first."
result := renderer.Render(template, context)
// Result: "Launch developer agent to implement task T-E07-F21-002. Write tests first."
```

### Integration Point

Used in `internal/cli/commands/task.go` when returning orchestrator actions:

```go
// When task status transitions
action := config.GetOrchestratorAction(newStatus)
if action != nil {
    // Render template with task context
    renderer := template.NewRenderer()
    context := map[string]string{
        "task_id": task.Key,
    }
    action.Instruction = renderer.Render(action.InstructionTemplate, context)
}
```

## Implementation Details

### Package Location

- **Path**: `internal/template/renderer.go`
- **Package**: `template`
- **Exported Types**: `TemplateRenderer` interface, `NewRenderer()` function

### Implementation Strategy

**Phase 1: Simple String Replacement**

```go
type simpleRenderer struct{}

func (r *simpleRenderer) Render(template string, context map[string]string) string {
    result := template
    for key, value := range context {
        placeholder := fmt.Sprintf("{%s}", key)
        result = strings.ReplaceAll(result, placeholder, value)
    }
    return result
}
```

**Rationale**:
- Simple to implement and understand
- No external dependencies
- Sufficient for initial use case
- Easy to replace with more sophisticated engine later

### Error Handling

**Phase 1: Lenient Approach**
- Unknown variables left as-is (e.g., `{unknown}` stays `{unknown}`)
- Empty template returns empty string
- Nil context treated as empty map
- No errors thrown (fail-safe for orchestrators)

**Future**: Add strict mode for validation

### Performance Considerations

- Target: <1ms per template render
- Benchmark with 100-character templates
- Optimize if rendering becomes bottleneck (pre-compile placeholders)

## Acceptance Criteria

### Functional Requirements

- [ ] `TemplateRenderer` interface defined with `Render(template, context)` method
- [ ] `NewRenderer()` constructor returns functional renderer
- [ ] `{task_id}` variable replaced correctly when present in context
- [ ] Multiple occurrences of same variable all replaced
- [ ] Unknown variables left unchanged (no error)
- [ ] Empty template returns empty string
- [ ] Nil/empty context handled gracefully

### Non-Functional Requirements

- [ ] Render performance <1ms per template (benchmark included)
- [ ] No external dependencies (use standard library only)
- [ ] Code is easily extensible for future variables
- [ ] API is backward compatible (can add methods without breaking existing code)

### Integration Requirements

- [ ] Can be called from CLI commands
- [ ] Works with orchestrator action config structure
- [ ] Integrates with existing Shark config loading

## Testing Requirements

### Unit Tests

**Test Cases**:

1. **Basic Substitution**
   - Template with `{task_id}`, context with task_id → correct replacement
   - Template with multiple `{task_id}` → all replaced
   - Template with no variables → unchanged

2. **Edge Cases**
   - Empty template → empty result
   - Empty context → variables unchanged
   - Nil context → handled gracefully
   - Variable not in context → left as-is
   - Malformed variables (`{task_id`, `task_id}`) → left as-is

3. **Context Variations**
   - Single variable in context
   - Multiple variables in context (only task_id used)
   - Case sensitivity: `{Task_Id}` vs `{task_id}`

4. **Performance**
   - Benchmark: 1000 renders of 100-char template
   - Target: <1ms average per render

### Example Test

```go
func TestRenderer_BasicSubstitution(t *testing.T) {
    renderer := NewRenderer()

    tests := []struct {
        name     string
        template string
        context  map[string]string
        want     string
    }{
        {
            name:     "single task_id",
            template: "Implement task {task_id}",
            context:  map[string]string{"task_id": "T-E07-F21-002"},
            want:     "Implement task T-E07-F21-002",
        },
        {
            name:     "multiple task_id",
            template: "Task {task_id} ({task_id})",
            context:  map[string]string{"task_id": "T-001"},
            want:     "Task T-001 (T-001)",
        },
        {
            name:     "unknown variable",
            template: "Task {task_id} with {unknown}",
            context:  map[string]string{"task_id": "T-001"},
            want:     "Task T-001 with {unknown}",
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got := renderer.Render(tt.template, tt.context)
            if got != tt.want {
                t.Errorf("Render() = %q, want %q", got, tt.want)
            }
        })
    }
}
```

### Integration Tests

- [ ] Load orchestrator action from config with template
- [ ] Render template with task context
- [ ] Verify rendered instruction in task update response

## Future Extensibility

### Design Considerations

**Interface Stability**:
- `TemplateRenderer` interface should not change
- Add new methods for advanced features
- Keep simple `Render()` for common case

**Adding New Variables** (Phase 2):
```go
// Context builder helper
func BuildTaskContext(task *models.Task) map[string]string {
    return map[string]string{
        "task_id":    task.Key,
        "epic_id":    task.EpicKey,      // Phase 2
        "feature_id": task.FeatureKey,   // Phase 2
        "task_title": task.Title,        // Phase 2
        "status":     task.Status,       // Phase 2
    }
}
```

**Advanced Template Engine** (Phase 3+):
- Conditional logic: `{if priority > 5}urgent{endif}`
- Loops: `{for dep in dependencies}{dep}{endfor}`
- Functions: `{uppercase(task_title)}`

**Migration Path**:
1. Phase 1: Simple string replacement (this task)
2. Phase 2: Add more variables via context
3. Phase 3: Add template validation (strict mode)
4. Phase 4: Consider text/template or custom parser if needed

## Notes

- **Keep it simple**: Avoid over-engineering for initial use case
- **Document assumptions**: Phase 1 only supports `{task_id}`
- **Future-proof**: Design allows easy addition of variables
- **No magic**: Explicit context passing, no global state
- **Fail-safe**: Unknown variables preserved, no panics
