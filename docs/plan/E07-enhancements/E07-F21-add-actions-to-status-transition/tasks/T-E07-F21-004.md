
---
key: T-E07-F21-004
title: Create config service layer
epic: E07
feature: E07-F21
agent: backend
status: todo
priority: 9
depends_on: ["T-E07-F21-001"]
created_at: 2026-01-15T01:52:55Z
---

# Task: Create config service layer

## Goal

Create a service layer abstraction in `internal/config/` to query orchestrator actions from workflow configuration. This service provides a clean API for CLI commands and repository layer to fetch action instructions without directly accessing raw config structures.

**Why this matters**: The config service layer decouples business logic from configuration file structure. It provides caching, template population, and validation, making it easy to test CLI commands with mock services and improving performance with repeated config queries.

**Key Benefits**:
- **Testability**: CLI commands can use mocked service instead of real config files
- **Performance**: In-memory caching prevents repeated JSON parsing (target: <10ms per query)
- **Simplicity**: Single API method `GetStatusAction(status, taskID)` handles template population
- **Maintainability**: Centralized config access logic in one package

## Service Architecture

### Package Location

`internal/config/action_service.go` (new file)

### Service Interface

```go
package config

import "context"

// ActionService provides access to orchestrator action configuration
type ActionService interface {
    // GetStatusAction returns the orchestrator action for a given status
    // Returns nil if no action is defined for the status
    GetStatusAction(ctx context.Context, status string) (*OrchestratorAction, error)

    // GetStatusActionPopulated returns action with template variables populated
    GetStatusActionPopulated(ctx context.Context, status string, taskID string) (*PopulatedAction, error)

    // GetAllActions returns all orchestrator actions indexed by status name
    GetAllActions(ctx context.Context) (map[string]*OrchestratorAction, error)

    // ValidateActions checks that all actionable statuses have valid actions
    // Returns list of statuses missing actions or with invalid configuration
    ValidateActions(ctx context.Context) (*ValidationResult, error)

    // Reload forces reload of configuration from disk (useful after config changes)
    Reload(ctx context.Context) error
}

// PopulatedAction is an orchestrator action with template variables replaced
type PopulatedAction struct {
    Action      string   `json:"action"`
    AgentType   string   `json:"agent_type,omitempty"`
    Skills      []string `json:"skills,omitempty"`
    Instruction string   `json:"instruction"` // Template populated
}

// ValidationResult contains status action validation results
type ValidationResult struct {
    Valid          bool             `json:"valid"`
    MissingActions []string         `json:"missing_actions,omitempty"` // Statuses without actions
    InvalidActions []InvalidAction  `json:"invalid_actions,omitempty"` // Actions with validation errors
    Warnings       []string         `json:"warnings,omitempty"`        // Non-fatal issues
}

// InvalidAction describes an action that failed validation
type InvalidAction struct {
    Status string `json:"status"`
    Error  string `json:"error"`
}
```

## Implementation Details

### Concrete Implementation

```go
// DefaultActionService is the default implementation of ActionService
type DefaultActionService struct {
    configPath     string
    workflow       *WorkflowConfig // Cached workflow config
    workflowParser *WorkflowParser // Parser for config files
}

// NewActionService creates a new action service
func NewActionService(configPath string) (*DefaultActionService, error) {
    parser := NewWorkflowParser()

    service := &DefaultActionService{
        configPath:     configPath,
        workflowParser: parser,
    }

    // Load initial config
    if err := service.Reload(context.Background()); err != nil {
        return nil, fmt.Errorf("failed to load initial config: %w", err)
    }

    return service, nil
}

// GetStatusAction retrieves action for a status
func (s *DefaultActionService) GetStatusAction(ctx context.Context, status string) (*OrchestratorAction, error) {
    if s.workflow == nil {
        return nil, errors.New("workflow config not loaded")
    }

    metadata, exists := s.workflow.StatusMetadata[status]
    if !exists {
        return nil, &StatusNotFoundError{Status: status}
    }

    // Return nil if no action defined (not an error)
    return metadata.OrchestratorAction, nil
}

// GetStatusActionPopulated retrieves action with template populated
func (s *DefaultActionService) GetStatusActionPopulated(ctx context.Context, status string, taskID string) (*PopulatedAction, error) {
    action, err := s.GetStatusAction(ctx, status)
    if err != nil {
        return nil, err
    }

    if action == nil {
        return nil, nil // No action defined
    }

    // Populate template
    instruction := action.PopulateTemplate(taskID)

    return &PopulatedAction{
        Action:      action.Action,
        AgentType:   action.AgentType,
        Skills:      action.Skills,
        Instruction: instruction,
    }, nil
}

// GetAllActions returns all actions indexed by status
func (s *DefaultActionService) GetAllActions(ctx context.Context) (map[string]*OrchestratorAction, error) {
    if s.workflow == nil {
        return nil, errors.New("workflow config not loaded")
    }

    actions := make(map[string]*OrchestratorAction)
    for status, metadata := range s.workflow.StatusMetadata {
        if metadata.OrchestratorAction != nil {
            actions[status] = metadata.OrchestratorAction
        }
    }

    return actions, nil
}

// ValidateActions validates all orchestrator actions in config
func (s *DefaultActionService) ValidateActions(ctx context.Context) (*ValidationResult, error) {
    if s.workflow == nil {
        return nil, errors.New("workflow config not loaded")
    }

    result := &ValidationResult{
        Valid:          true,
        MissingActions: []string{},
        InvalidActions: []InvalidAction{},
        Warnings:       []string{},
    }

    for status, metadata := range s.workflow.StatusMetadata {
        // Check if actionable status (ready_for_*) lacks action
        if strings.HasPrefix(status, "ready_for_") && metadata.OrchestratorAction == nil {
            result.MissingActions = append(result.MissingActions, status)
            result.Warnings = append(result.Warnings,
                fmt.Sprintf("Status '%s' has no orchestrator_action defined", status))
        }

        // Validate action if present
        if metadata.OrchestratorAction != nil {
            if err := metadata.OrchestratorAction.Validate(); err != nil {
                result.Valid = false
                result.InvalidActions = append(result.InvalidActions, InvalidAction{
                    Status: status,
                    Error:  err.Error(),
                })
            }
        }
    }

    // Set overall validity
    if len(result.InvalidActions) > 0 {
        result.Valid = false
    }

    return result, nil
}

// Reload reloads configuration from disk
func (s *DefaultActionService) Reload(ctx context.Context) error {
    workflow, err := s.workflowParser.Parse(s.configPath)
    if err != nil {
        return fmt.Errorf("failed to parse workflow config: %w", err)
    }

    s.workflow = workflow
    return nil
}
```

### Error Types

```go
// StatusNotFoundError indicates a status doesn't exist in config
type StatusNotFoundError struct {
    Status string
}

func (e *StatusNotFoundError) Error() string {
    return fmt.Sprintf("status '%s' not found in workflow configuration", e.Status)
}
```

## Integration with Existing Config Package

### Config Manager Integration

Update `internal/config/manager.go` to provide action service:

```go
// Manager now includes action service
type Manager struct {
    configPath    string
    config        *Config
    actionService *DefaultActionService // NEW
}

// GetActionService returns the action service for workflow queries
func (m *Manager) GetActionService() (*DefaultActionService, error) {
    if m.actionService == nil {
        service, err := NewActionService(m.configPath)
        if err != nil {
            return nil, fmt.Errorf("failed to create action service: %w", err)
        }
        m.actionService = service
    }
    return m.actionService, nil
}
```

## Caching Strategy

### In-Memory Cache

**Implementation**: Store parsed `WorkflowConfig` in `DefaultActionService.workflow` field.

**Benefits**:
- Eliminates repeated JSON parsing (target: <10ms per query vs ~50ms for file read + parse)
- Thread-safe (read-only after initial load)
- Simple implementation (no external cache dependencies)

**Cache Invalidation**:
- Manual reload via `Reload()` method
- CLI commands call `Reload()` after config changes
- Orchestrators can poll or watch config file changes

**Performance Target**:
- Initial load: <100ms (REQ-NF-002)
- Cached queries: <1ms per status lookup
- Memory overhead: ~50KB for typical workflow config

### Thread Safety

**Read-Only Operations**: `GetStatusAction`, `GetAllActions` are safe for concurrent access (no writes after initialization).

**Write Operations**: `Reload()` should replace entire `workflow` pointer atomically (use `sync.RWMutex` if needed).

```go
type DefaultActionService struct {
    mu             sync.RWMutex     // Protects workflow field
    configPath     string
    workflow       *WorkflowConfig
    workflowParser *WorkflowParser
}

// GetStatusAction with read lock
func (s *DefaultActionService) GetStatusAction(ctx context.Context, status string) (*OrchestratorAction, error) {
    s.mu.RLock()
    defer s.mu.RUnlock()

    // ... implementation ...
}

// Reload with write lock
func (s *DefaultActionService) Reload(ctx context.Context) error {
    workflow, err := s.workflowParser.Parse(s.configPath)
    if err != nil {
        return err
    }

    s.mu.Lock()
    s.workflow = workflow
    s.mu.Unlock()

    return nil
}
```

## Usage Examples

### CLI Command Usage

```go
// In internal/cli/commands/task.go
func runTaskUpdate(cmd *cobra.Command, args []string) error {
    // Get config manager
    configMgr := config.NewManager(".sharkconfig.json")

    // Get action service
    actionService, err := configMgr.GetActionService()
    if err != nil {
        return fmt.Errorf("failed to get action service: %w", err)
    }

    // Update task status
    // ... status update logic ...

    // Get orchestrator action for new status
    action, err := actionService.GetStatusActionPopulated(ctx, newStatus, taskKey)
    if err != nil {
        var notFoundErr *config.StatusNotFoundError
        if errors.As(err, &notFoundErr) {
            // Status exists but no action defined (valid)
            return outputTaskResult(task, nil)
        }
        return fmt.Errorf("failed to get orchestrator action: %w", err)
    }

    // Include action in response
    return outputTaskResult(task, action)
}
```

### Mock Service for Testing

```go
// In tests
type MockActionService struct {
    GetStatusActionFunc func(ctx context.Context, status string) (*config.OrchestratorAction, error)
}

func (m *MockActionService) GetStatusAction(ctx context.Context, status string) (*config.OrchestratorAction, error) {
    if m.GetStatusActionFunc != nil {
        return m.GetStatusActionFunc(ctx, status)
    }
    return nil, nil
}

// Test with mock
func TestTaskUpdate_WithAction(t *testing.T) {
    mockService := &MockActionService{
        GetStatusActionFunc: func(ctx context.Context, status string) (*config.OrchestratorAction, error) {
            return &config.OrchestratorAction{
                Action:    "spawn_agent",
                AgentType: "developer",
            }, nil
        },
    }

    // Test command with mock service
}
```

## Acceptance Criteria

- [ ] `ActionService` interface defined with 5 core methods
- [ ] `DefaultActionService` implements all interface methods
- [ ] `GetStatusAction()` returns action or nil if not defined
- [ ] `GetStatusActionPopulated()` replaces {task_id} template variable
- [ ] `GetAllActions()` returns map of all status actions
- [ ] `ValidateActions()` checks actionable statuses have actions
- [ ] `Reload()` reloads config from disk
- [ ] Thread-safe caching with `sync.RWMutex`
- [ ] `StatusNotFoundError` custom error type
- [ ] Config manager provides `GetActionService()` method
- [ ] Performance: Cached queries <1ms, initial load <100ms
- [ ] Service works with both complete and minimal configs (backward compat)

## Testing Requirements

### Unit Tests

Create `internal/config/action_service_test.go`:

- [ ] **TestNewActionService**: Create service successfully
- [ ] **TestNewActionService_InvalidConfig**: Fails with clear error for bad config
- [ ] **TestGetStatusAction_Valid**: Returns action for status with action defined
- [ ] **TestGetStatusAction_NoAction**: Returns nil for status without action (not error)
- [ ] **TestGetStatusAction_StatusNotFound**: Returns StatusNotFoundError for unknown status
- [ ] **TestGetStatusActionPopulated**: {task_id} replaced correctly
- [ ] **TestGetStatusActionPopulated_NoPlaceholder**: Works with templates without {task_id}
- [ ] **TestGetAllActions**: Returns all actions indexed by status
- [ ] **TestGetAllActions_EmptyConfig**: Returns empty map for config without actions
- [ ] **TestValidateActions_AllValid**: Returns valid result for complete config
- [ ] **TestValidateActions_MissingActions**: Lists statuses missing actions
- [ ] **TestValidateActions_InvalidAction**: Detects invalid action schema
- [ ] **TestReload**: Config changes reflected after reload
- [ ] **TestThreadSafety**: Concurrent reads + reload don't cause race conditions

### Integration Tests

Create `internal/config/action_service_integration_test.go`:

- [ ] **TestActionService_WithRealConfig**: Load and query actual .sharkconfig.json
- [ ] **TestActionService_ConfigManager_Integration**: Manager provides working service
- [ ] **TestActionService_Performance**: Cached queries meet <1ms target

### Mock Implementation

Create `internal/config/mock_action_service.go` for CLI testing:

```go
type MockActionService struct {
    GetStatusActionFunc          func(ctx context.Context, status string) (*OrchestratorAction, error)
    GetStatusActionPopulatedFunc func(ctx context.Context, status string, taskID string) (*PopulatedAction, error)
    GetAllActionsFunc            func(ctx context.Context) (map[string]*OrchestratorAction, error)
    ValidateActionsFunc          func(ctx context.Context) (*ValidationResult, error)
    ReloadFunc                   func(ctx context.Context) error
}

// Implement all ActionService methods
```

## Files to Create

1. **internal/config/action_service.go** - Service implementation (~300 lines)
   - `ActionService` interface
   - `DefaultActionService` struct
   - `PopulatedAction`, `ValidationResult` types
   - `StatusNotFoundError` error type

2. **internal/config/action_service_test.go** - Unit tests (~400 lines)
   - All service methods tested
   - Edge cases covered
   - Performance benchmarks

3. **internal/config/action_service_integration_test.go** - Integration tests (~150 lines)
   - Real config file tests
   - Config manager integration

4. **internal/config/mock_action_service.go** - Mock for CLI tests (~100 lines)
   - Mock implementation for testing
   - Function field pattern for flexibility

## Files to Modify

1. **internal/config/manager.go** - Add action service support (~20 lines added)
   - Add `actionService` field to Manager
   - Add `GetActionService()` method

2. **internal/config/manager_test.go** - Test manager integration (~50 lines added)
   - Test `GetActionService()` returns working service
   - Test service caching (same instance returned)

## Documentation Requirements

- [ ] Add action service section to config package godoc
- [ ] Document caching behavior and thread safety
- [ ] Provide example usage in CLI commands
- [ ] Document mock service usage for testing
- [ ] Add performance characteristics to godoc

## Performance Requirements

**Target Metrics** (REQ-NF-001, REQ-NF-002 from PRD):

1. **Initial Load**: <100ms
   - Parse .sharkconfig.json
   - Validate orchestrator_action schemas
   - Cache in memory

2. **Cached Queries**: <1ms
   - `GetStatusAction()` lookup
   - Map access only, no file I/O

3. **Template Population**: <1ms
   - Simple string replacement
   - No regex or complex parsing

4. **Validation**: <50ms
   - Iterate all status_metadata entries
   - Run OrchestratorAction.Validate() on each

**Benchmark Tests**:

```go
func BenchmarkGetStatusAction(b *testing.B) {
    service := setupTestService()
    ctx := context.Background()

    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        _, _ = service.GetStatusAction(ctx, "ready_for_development")
    }
}

func BenchmarkGetStatusActionPopulated(b *testing.B) {
    service := setupTestService()
    ctx := context.Background()

    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        _, _ = service.GetStatusActionPopulated(ctx, "ready_for_development", "T-E07-F21-001")
    }
}
```

## Related Documents

- Feature PRD: `docs/plan/E07-enhancements/E07-F21-add-actions-to-status-transition/feature.md`
- Schema Task: `T-E07-F21-001` (defines OrchestratorAction struct and validation)
- Workflow Config Design: `docs/plan/E07-enhancements/E07-F21-add-actions-to-status-transition/shark-workflow-config-design.md`

## Notes

**Design Decisions**:

1. **Interface-Based Design**: `ActionService` interface allows mocking in tests without complex setup.

2. **Simple Caching**: In-memory cache is sufficient. No need for Redis/Memcached for config queries.

3. **Nil vs Error**: `GetStatusAction()` returns `nil` (not error) when action is undefined. This allows backward compatibilityâ€”missing actions are valid.

4. **Template Population**: Simple string replacement is sufficient for v1. Advanced template engine (text/template) can be added in Phase 4 if needed.

5. **Thread Safety**: `sync.RWMutex` protects workflow field. Read operations are common (many queries), write operations are rare (config reload).

**Performance Considerations**:

- Config file is small (~10KB for typical workflow), full load is fast
- Caching eliminates repeated file I/O and JSON parsing
- Map lookups are O(1) for status action queries
- Template population is simple string replacement (no regex)

**Testing Strategy**:

- Unit tests use in-memory config (no file I/O)
- Integration tests use real .sharkconfig.json file
- CLI tests use mock service (no config file dependency)
- Benchmarks ensure performance targets met
