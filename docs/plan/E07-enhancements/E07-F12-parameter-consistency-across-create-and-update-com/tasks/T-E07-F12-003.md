---
agent: backend
created_at: 2026-01-01T07:35:50Z
epic: E07
feature: E07-F12
key: T-E07-F12-003
priority: 8
status: todo
task_key: T-E07-F12-012
title: Create file_assignment.go with collision detection
---


# Task: Create file_assignment.go with collision detection

## Goal

Create a shared file assignment module that handles file collision detection and reassignment logic with --force flag support. This eliminates duplicate collision detection code across epic and feature commands.

## Related Documentation

- Implementation Plan: dev-artifacts/2026-01-01-parameter-consistency-research/implementation-plan.md (lines 195-271)

## Implementation Details

### File to Create

- Location: internal/cli/commands/file_assignment.go

### API Design

Create the following types and functions:

```go
// FileCollision represents a file path conflict
type FileCollision struct {
    FilePath string
    Epic     *models.Epic   // Non-nil if epic claims this file
    Feature  *models.Feature // Non-nil if feature claims this file
}

// Collision detection and handling
func DetectFileCollision(
    ctx context.Context,
    filePath string,
    epicRepo *repository.EpicRepository,
    featureRepo *repository.FeatureRepository,
) (*FileCollision, error)

func HandleFileReassignment(
    ctx context.Context,
    collision *FileCollision,
    force bool,
    epicRepo *repository.EpicRepository,
    featureRepo *repository.FeatureRepository,
) error

func CreateBackupIfForce(force bool, dbPath string, operation string) (string, error)
```

### Implementation Strategy

1. Extract collision detection logic from epic.go and feature.go
2. Identify common patterns for file reassignment
3. Create reusable functions with repository injection
4. Write comprehensive tests with MOCKED repositories
5. DO NOT modify epic.go or feature.go yet (that's Phase 3)

### Collision Detection Logic

DetectFileCollision should:
1. Query epic repository for file path
2. Query feature repository for file path
3. Return FileCollision if found (with Epic or Feature populated)
4. Return nil if no collision exists

### Reassignment Logic

HandleFileReassignment should:
1. Return nil if no collision
2. If collision and force=false, return descriptive error
3. If collision and force=true, clear the file path from existing entity
4. Log the reassignment action

### Backup Logic

CreateBackupIfForce should:
1. Return empty string if force=false
2. Create timestamped database backup if force=true
3. Return backup path on success

## Acceptance Criteria

- [ ] DetectFileCollision queries both epic and feature repos
- [ ] FileCollision struct correctly identifies claiming entity
- [ ] HandleFileReassignment enforces --force requirement
- [ ] HandleFileReassignment clears old file path when force=true
- [ ] CreateBackupIfForce creates timestamped backups
- [ ] All functions use injected repository dependencies
- [ ] Error messages provide clear context
- [ ] No changes to epic.go or feature.go

## Testing Requirements

### Unit Tests (file_assignment_test.go)

**CRITICAL: Use MOCKED repositories - never real database**

- [ ] TestDetectFileCollision_NoCollision - No file claimed
- [ ] TestDetectFileCollision_EpicClaimed - Epic claims the file
- [ ] TestDetectFileCollision_FeatureClaimed - Feature claims the file
- [ ] TestDetectFileCollision_RepositoryError - Handle query errors
- [ ] TestHandleFileReassignment_NoCollision - Pass-through case
- [ ] TestHandleFileReassignment_WithoutForce - Error on collision
- [ ] TestHandleFileReassignment_WithForce_Epic - Reassign from epic
- [ ] TestHandleFileReassignment_WithForce_Feature - Reassign from feature
- [ ] TestCreateBackupIfForce_NotForced - No backup created
- [ ] TestCreateBackupIfForce_Forced - Backup created with timestamp

### Mock Design

Create mock repositories with:
- GetByFilePathFunc for testing collision detection
- UpdateFunc for testing reassignment

### Coverage Target

- 95%+ coverage for file_assignment.go

## Notes

- This is Phase 2 Task 3 of 5
- Extracts file collision logic into reusable functions
- Must be completed before Phase 3 refactoring
- Follow TDD: write tests first, then implementation
- All tests use MOCKED repositories (no real database)
- Repository injection allows testing without database
