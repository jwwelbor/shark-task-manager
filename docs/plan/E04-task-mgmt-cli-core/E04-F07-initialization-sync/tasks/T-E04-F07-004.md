---
task_key: T-E04-F07-004
status: created
feature: /docs/plan/E04-task-mgmt-cli-core/E04-F07-initialization-sync
created: 2025-12-16
assigned_agent: api-developer
dependencies: [T-E04-F07-001.md]
estimated_time: 8 hours
---

# Task: Conflict Detection and Resolution

## Goal

Implement conflict detection and resolution logic to handle discrepancies between task file metadata and database records, applying configurable strategies (file-wins, database-wins, newer-wins) while preserving database-only fields.

## Success Criteria

- [ ] ConflictDetector identifies conflicts in title, description, file_path
- [ ] No false positives (database-only fields don't trigger conflicts)
- [ ] ConflictResolver applies file-wins strategy correctly
- [ ] ConflictResolver applies database-wins strategy correctly
- [ ] ConflictResolver applies newer-wins strategy with timestamp comparison
- [ ] Database-only fields (status, priority, agent_type) always preserved
- [ ] Conflict details captured for reporting
- [ ] All validation gates pass

## Implementation Guidance

### Overview

Create conflict detection and resolution components within `internal/sync` package. The detector compares file metadata with database records field-by-field. The resolver applies the chosen strategy while ensuring database-only fields remain unchanged.

### Key Requirements

- Detect conflicts for metadata fields only - See [Contract - ConflictResolver Interface](../01-interface-contracts.md#conflictresolver-interface)
- Field comparison rules (title, description, file_path) - See [Contract - Field Comparison Rules](../01-interface-contracts.md#conflictresolver-interface)
- Apply resolution strategies consistently - See [Architecture - ConflictResolver](../02-architecture.md#conflictresolver)
- Preserve database-only fields in all strategies - See [Contract - Resolution Strategy](../01-interface-contracts.md#conflictresolver-interface)
- Use UpdateMetadata repository method - See [Task 001 - Repository Extensions](./T-E04-F07-001.md)

### Files to Create/Modify

**Backend**:
- `internal/sync/conflict.go` - ConflictDetector implementation
- `internal/sync/resolver.go` - ConflictResolver implementation
- `internal/sync/types.go` - Conflict, ConflictStrategy types
- `internal/sync/conflict_test.go` - Unit tests for detector
- `internal/sync/resolver_test.go` - Unit tests for resolver

### Integration Points

- SyncEngine calls detector during task comparison phase
- Resolver output feeds directly to TaskRepository.UpdateMetadata
- Conflict details added to SyncReport for user visibility

Reference: [Architecture - Conflict Detection & Resolution](../02-architecture.md#conflictdetector)

## Validation Gates

**Linting & Type Checking**:
- Go code passes all linters
- No type errors

**Unit Tests**:
- Detector identifies title conflicts when file differs from DB
- Detector identifies description conflicts
- Detector always flags file_path conflicts (file moved)
- Detector does NOT flag status, priority, agent_type changes
- File-wins strategy updates database with file values
- Database-wins strategy keeps database unchanged
- Newer-wins compares file.ModifiedAt vs db.UpdatedAt correctly
- All strategies preserve status, priority, agent_type fields
- Handle nil pointer cases (description can be nil)

**Integration Tests**:
- Conflict resolution with real Task models
- Resolved tasks can be saved to database
- Multiple conflicts in single task handled correctly

## Context & Resources

- **Architecture**: [ConflictDetector & Resolver](../02-architecture.md#conflictdetector)
- **Contracts**: [ConflictResolver Interface](../01-interface-contracts.md#conflictresolver-interface)
- **Backend Design**: [conflict.go & resolver.go](../04-backend-design.md#conflictgo)
- **Data Design**: [Field Comparison Rules](../03-data-design.md#conflict-detection-logic)
- **Implementation Phases**: [Phase 4](../08-implementation-phases.md#phase-4-conflict-detection--resolution)

## Notes for Agent

- Title conflict: only if file has title AND differs (empty file title = no conflict)
- Description: use pointer comparison (nil != empty string)
- File path: always update to actual location (not really a "conflict")
- Database-only fields: status, priority, agent_type, depends_on, assigned_agent
- Create copy of database task, apply changes, return modified copy
- Newer-wins: file.ModifiedAt > db.UpdatedAt â†’ use file value
- Build Conflict struct for each detected difference (for reporting)
- Consider using reflect or explicit field-by-field comparison
