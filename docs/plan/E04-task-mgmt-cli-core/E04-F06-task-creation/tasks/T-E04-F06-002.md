---
task_key: T-E04-F06-002
status: todo
feature: /home/jwwelbor/.claude/docs/plan/E04-task-mgmt-cli-core/E04-F06-task-creation
created: 2025-12-14
assigned_agent: general-purpose
dependencies: ["T-E04-F01-006"]
estimated_time: 5 hours
file_path: /home/jwwelbor/.claude/docs/tasks/todo/T-E04-F06-002.md
---

# Task: Key Generation & Validation

## Goal

Implement automatic task key generation with sequential numbering, comprehensive input validation for all task creation parameters, and dependency verification to ensure data integrity.

## Success Criteria

- [ ] Automatic key generation finds next available task number for a feature
- [ ] Key format: `T-<epic-key>-<feature-key>-<zero-padded-number>` (e.g., T-E01-F02-003)
- [ ] Numbers zero-padded to 2 digits (01, 02, ..., 99) (there should not be more than 99 tasks per feature - 00 would be reserved for a readme type file.)
- [ ] Concurrent creation handled (database locks prevent duplicate keys)
- [ ] Epic existence validation (raises error if epic doesn't exist)
- [ ] Feature existence validation (raises error if feature doesn't exist or doesn't belong to epic)
- [ ] Feature key normalization (F02 → E01-F02 when epic provided)
- [ ] Agent type validation (must be one of: frontend, backend, api, testing, devops, general)
- [ ] Priority validation (must be integer 1-10)
- [ ] Dependency validation (all referenced task keys must exist in database)
- [ ] Error messages are specific and actionable
- [ ] Maximum task count per feature enforced (999 tasks, raise error if exceeded)

## Implementation Guidance

### Overview

This task implements the core logic for generating unique task keys and validating all inputs before task creation. Proper key generation prevents conflicts and maintains consistent naming. Comprehensive validation ensures only valid tasks are created, preventing broken references and data integrity issues.

### Key Requirements

- **Key Generation Logic**: Per [PRD - Automatic Key Generation Requirements 5-9](../prd.md#automatic-key-generation)
  - Query database for highest task number in feature: `SELECT MAX(key) FROM tasks WHERE feature_id = ?`
  - Extract number from key (e.g., "T-E01-F02-42" → 42) using regex or string parsing
  - Increment by 1 and zero-pad to 2 digits: `fmt.Sprintf("%02d", num)`
  - If no tasks exist for feature, start with "01"
  - If 99 tasks exist, return error: "Error: Feature E01-F02 has reached maximum task count (99)"
  - Generate full key: `fmt.Sprintf("T-%s-%s-%s", epicKey, featureKey, number)`

- **Concurrent Creation Safety**: Per [PRD - Requirement 9](../prd.md#automatic-key-generation)
  - Use database transaction with row-level locking (BEGIN IMMEDIATE for SQLite)
  - Ensure two simultaneous creates don't generate same key
  - Rely on database UNIQUE constraint as final safety net
  - Use Go's database/sql transaction support (`tx.Begin()`)

- **Epic Validation**: Per [PRD - Requirement 10](../prd.md#input-validation)
  - Query epics table: `SELECT id FROM epics WHERE key = ?`
  - If not found, return error: "Error: Epic E99 does not exist. Use 'pm epic list' to see available epics."

- **Feature Validation**: Per [PRD - Requirement 11](../prd.md#input-validation)
  - Query features table: `SELECT id, epic_id FROM features WHERE key = ?`
  - Verify feature.epic_id matches provided epic
  - If feature not found: "Error: Feature E01-F99 does not exist"
  - If epic mismatch: "Error: Feature E01-F02 does not belong to epic E99"

- **Feature Key Normalization**: Per [PRD - Requirement 12](../prd.md#input-validation)
  - If user provides `--feature=F02`, prepend epic key: `E01-F02`
  - Accept both `--feature=F02` and `--feature=E01-F02` formats
  - Use `strings.HasPrefix()` to check if normalization needed

- **Agent Type Validation**: Per [PRD - Requirement 13](../prd.md#input-validation)
  - Valid values: frontend, backend, api, testing, devops, general
  - Use validation from E04-F01 if available, or implement with map or const validation
  - Error: "Error: Invalid agent type 'invalid-agent'. Must be one of: frontend, backend, api, testing, devops, general"

- **Priority Validation**: Per [PRD - Requirement 14](../prd.md#input-validation)
  - Must be integer between 1 and 10 (inclusive)
  - Error: "Error: Priority must be between 1 and 10, got 15"

- **Dependency Validation**: Per [PRD - Requirements 15-16](../prd.md#input-validation)
  - Parse comma-separated list: `strings.Split(dependsOn, ",")`
  - Trim whitespace from each item: `strings.TrimSpace()`
  - For each task key, query: `SELECT key FROM tasks WHERE key = ?`
  - If not found: "Error: Dependency task T-E01-F99-001 does not exist"
  - Return validated slice of task keys

### Files to Create/Modify

**New Files**:
- `internal/taskcreation/keygen.go` - Key generation logic (~200 lines)
- `internal/taskcreation/validator.go` - Input validation functions (~350 lines)
- `internal/taskcreation/keygen_test.go` - Key generation tests (~250 lines)
- `internal/taskcreation/validator_test.go` - Validation tests (~300 lines)

**Modified Files**:
- `cmd/pm/main.go` - Wire up task creation components

### Integration Points

- **Database (E04-F01)**: Query epics, features, tasks tables for validation
- **Database Repositories (E04-F01)**: Use EpicRepository, FeatureRepository, TaskRepository for queries
- **Session Management (E04-F01)**: Use SessionFactory for database access
- **Task Creation Command (T-E04-F06-003)**: Command will call validators before creating task

### Key Generation Algorithm

```go
// Pseudo-code
func GenerateTaskKey(epicKey, featureKey string) (string, error) {
    // 1. Normalize feature_key (prepend epic if needed)
    normalizedFeatureKey := normalizeFeatureKey(epicKey, featureKey)

    // 2. Query: feature = getFeatureByKey(featureKey)
    feature, err := featureRepo.GetByKey(normalizedFeatureKey)
    if err != nil {
        return "", err
    }

    // 3. Query: maxKey = SELECT MAX(key) FROM tasks WHERE feature_id = ?
    maxKey, err := taskRepo.GetMaxKeyForFeature(feature.ID)

    // 4. Determine next number
    var nextNumber int
    if maxKey == "" {
        nextNumber = 1
    } else {
        // Extract number using regex: T-E\d+-F\d+-(\d+)
        extractedNum := extractNumberFromKey(maxKey)
        nextNumber = extractedNum + 1
    }

    // 5. Check limit
    if nextNumber > 999 {
        return "", fmt.Errorf("Feature %s has reached maximum task count (999)", normalizedFeatureKey)
    }

    // 6. Pad and build key
    numberStr := fmt.Sprintf("%03d", nextNumber)
    key := fmt.Sprintf("T-%s-%s-%s", epicKey, normalizedFeatureKey, numberStr)

    return key, nil
}
```

### Validation Flow

```go
// Pseudo-code
type ValidatedTaskData struct {
    EpicID           int
    FeatureID        int
    ValidatedDepsOn  []string
}

func ValidateTaskInput(input TaskInput) (*ValidatedTaskData, error) {
    // 1. Validate epic exists → get epic_id
    epic, err := epicRepo.GetByKey(input.EpicKey)
    if err != nil {
        return nil, fmt.Errorf("Epic %s does not exist. Use 'pm epic list' to see available epics", input.EpicKey)
    }

    // 2. Validate feature exists and belongs to epic → get feature_id
    feature, err := featureRepo.GetByKey(input.FeatureKey)
    if err != nil {
        return nil, fmt.Errorf("Feature %s does not exist", input.FeatureKey)
    }
    if feature.EpicID != epic.ID {
        return nil, fmt.Errorf("Feature %s does not belong to epic %s", input.FeatureKey, input.EpicKey)
    }

    // 3. Validate agent type
    if err := validateAgentType(input.AgentType); err != nil {
        return nil, err
    }

    // 4. Validate priority
    if input.Priority < 1 || input.Priority > 10 {
        return nil, fmt.Errorf("Priority must be between 1 and 10, got %d", input.Priority)
    }

    // 5. Validate dependencies
    validatedDeps := []string{}
    if input.DependsOn != "" {
        deps := strings.Split(input.DependsOn, ",")
        for _, dep := range deps {
            dep = strings.TrimSpace(dep)
            if dep == "" {
                continue
            }
            exists, err := taskRepo.Exists(dep)
            if err != nil || !exists {
                return nil, fmt.Errorf("Dependency task %s does not exist", dep)
            }
            validatedDeps = append(validatedDeps, dep)
        }
    }

    // 6. Return validated data
    return &ValidatedTaskData{
        EpicID:          epic.ID,
        FeatureID:       feature.ID,
        ValidatedDepsOn: validatedDeps,
    }, nil
}
```

## Validation Gates

- **Key Generation Tests**: Per [PRD - Acceptance Criteria - Automatic Key Sequencing](../prd.md#automatic-key-sequencing)
  - Test first task in feature generates "001"
  - Test second task generates "002" (after "001" exists)
  - Test transition from "099" to "100" (handles 3-digit to 4-digit)
  - Test error when 999 tasks already exist
  - Test concurrent creation doesn't create duplicates (integration test)

- **Epic Validation Tests**: Per [PRD - Acceptance Criteria - Input Validation](../prd.md#input-validation)
  - Test valid epic passes
  - Test non-existent epic raises error with helpful message
  - Verify error message includes suggestion to run `pm epic list`

- **Feature Validation Tests**:
  - Test valid feature passes
  - Test non-existent feature raises error
  - Test feature belonging to wrong epic raises error
  - Test feature key normalization (F02 → E01-F02)

- **Agent Type Validation Tests**:
  - Test all 6 valid agent types pass
  - Test invalid agent type raises error
  - Verify error message lists all valid options

- **Priority Validation Tests**:
  - Test priorities 1-10 all pass
  - Test priority 0 raises error
  - Test priority 11 raises error
  - Test non-integer priority raises error

- **Dependency Validation Tests**: Per [PRD - Acceptance Criteria - Dependency Validation](../prd.md#dependency-validation)
  - Test valid single dependency passes
  - Test valid multiple dependencies pass (comma-separated)
  - Test non-existent dependency raises error
  - Test empty depends_on returns empty array

## Context & Resources

- **PRD**: [Task Creation & Templating PRD](../prd.md)
  - [Automatic Key Generation Requirements 5-9](../prd.md#automatic-key-generation)
  - [Input Validation Requirements 10-16](../prd.md#input-validation)
  - [Acceptance Criteria - Key Sequencing](../prd.md#automatic-key-sequencing)
  - [Acceptance Criteria - Input Validation](../prd.md#input-validation)
  - [Acceptance Criteria - Dependency Validation](../prd.md#dependency-validation)
- **Epic**: [E04 Task Management CLI](../../epic.md)
- **Database Schema**: Reference E04-F01 for table structures

## Notes for Agent

- **Zero Padding**: Use Go fmt.Sprintf: `fmt.Sprintf("%03d", number)` produces "001", "042", "999"
- **Number Extraction**: Extract number from existing key using regexp package: `regexp.MustCompile(`T-[^-]+-[^-]+-(\d+)`)` to capture the number. Use `FindStringSubmatch` to extract.
- **Transaction Safety**: Wrap key generation in database transaction using `database/sql` tx support. Use `BEGIN IMMEDIATE` for SQLite, or rely on UNIQUE constraint + retry logic with exponential backoff.
- **Feature Key Formats**: Handle both "F02" and "E01-F02" formats. Normalize by prepending epic key if needed: `if !strings.HasPrefix(featureKey, epicKey) { featureKey = fmt.Sprintf("%s-%s", epicKey, featureKey) }`
- **Error Message Quality**: Include actionable suggestions in errors using fmt.Errorf. Reference available commands users can run to fix the issue. Consider wrapping errors with context.
- **Dependency Parsing**: Handle whitespace in dependency list using strings.Split and strings.TrimSpace. Filter empty strings.
- **Validator Pattern**: Create small, focused validation functions (ValidateEpic, ValidateFeature, ValidateAgentType, etc.) that can be composed. Each returns error for failures.
- **Integration with Database**: Use repository pattern from E04-F01. Don't write raw SQL in validation logic; use repository methods. Accept interfaces for testability.
- **Testing Edge Cases**: Use table-driven tests for boundary conditions (0, 1, 10, 11 for priority; 000, 001, 999, 1000 for key numbers). Go's testing package makes this natural.
- **Go Error Handling**: Return errors, don't panic. Use sentinel errors or error types for specific validation failures. Consider using errors.Is() and errors.As() for error checking.
- **SQLite Driver**: Use `github.com/mattn/go-sqlite3` as the database/sql driver. Import with blank identifier: `_ "github.com/mattn/go-sqlite3"`
