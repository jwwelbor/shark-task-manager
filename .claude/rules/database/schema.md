---
paths: "{internal/db,internal/repository}/**/*"
---

# Database Schema & Configuration

This rule is loaded when working with database or repository files.

## Core Tables

- **epics**: Top-level organizational units (E04, E07, etc.)
  - `file_path`: File location within project
  - `slug`: Human-readable key suffix
- **features**: Features within epics (E04-F01, E04-F02, etc.)
  - `file_path`: File location within project
  - `slug`: Human-readable key suffix
- **tasks**: Atomic work items (T-E04-F06-001, etc.)
  - `file_path`: File location within project
  - `slug`: Human-readable key suffix
- **task_history**: Audit trail of task status changes

## SQLite Configuration

- **Foreign Keys**: Enabled (`PRAGMA foreign_keys = ON`)
- **WAL Mode**: Write-Ahead Logging for better concurrency
- **Indexes**: 10+ indexes for query performance
- **Triggers**: Auto-update timestamps, cascade deletes
- **Constraints**: NOT NULL, UNIQUE, CHECK, FOREIGN KEY

### Performance Settings

- **WAL Mode**: Better concurrency (writes don't block reads)
- **Busy Timeout**: 5-second timeout prevents immediate failures on contention
- **Memory Mapped I/O**: `mmap_size=30GB` for large databases
- **Cache Size**: `-64000` = ~64MB in-memory cache

### Indexes

Frequently queried columns (key, status, epic_id, feature_id) are indexed:
- Composite indexes on (epic_id, status) for filtered queries
- Index usage improves `task next`, filtering operations

## Task Lifecycle States

```
todo → in_progress → ready_for_review → completed
                  ↘ blocked ↗ (can return to todo)
```

Commands for state transitions:
- `start`: todo → in_progress
- `complete`: in_progress → ready_for_review
- `approve`: ready_for_review → completed
- `reopen`: ready_for_review → in_progress
- `block/unblock`: Any status ↔ blocked

## Progress Calculation

- Feature progress = (completed tasks / total tasks) × 100%
- Epic progress = sum of all feature progresses / number of features
- Calculated in repository layer, not stored (derived data)
- Calculated on-demand only when explicitly requested (e.g., `feature get`, `epic get`)

## Database Migrations

### Auto-Migration System

The database uses automatic migrations for backward compatibility:

- Migrations run automatically when `InitDB()` is called
- Each migration checks if columns already exist before adding them
- Safe to run multiple times - idempotent operations
- No manual migration scripts required for end users

## Slug Architecture

Shark supports **dual key format** for epics, features, and tasks, providing both machine-readable numeric keys and human-readable slugged keys.

### Key Formats

**Epics:**
- Numeric: `E04`
- Slugged: `E04-epic-name`

**Features:**
- Numeric: `E04-F02` or `F02`
- Slugged: `E04-F02-feature-name` or `F02-feature-name`

**Tasks:**
- Numeric: `T-E04-F02-001` or `E04-F02-001` (short format)
- Slugged: `T-E04-F02-001-task-name` or `E04-F02-001-task-name`

### How It Works

**Automatic Slug Generation:**
- Slugs are automatically generated from titles when entities are created
- Generated by lowercasing title, replacing spaces/underscores with hyphens, removing special characters
- Stored in the `slug` column alongside the numeric `key` column
- Examples:
  - "User Authentication" → `user-authentication`
  - "API_Design & Testing" → `api-design-testing`
  - "Deploy to Production!!!" → `deploy-to-production`

**Dual Key Lookup:**
- All CLI commands accept BOTH numeric and slugged keys
- Repository layer automatically detects format and performs appropriate lookup
- Numeric lookup is tried first for performance (exact match on `key` column)
- Slugged lookup parses the key and matches both numeric key + slug

**Database Schema:**
```sql
ALTER TABLE epics ADD COLUMN slug TEXT;
ALTER TABLE features ADD COLUMN slug TEXT;
ALTER TABLE tasks ADD COLUMN slug TEXT;

CREATE INDEX idx_epics_slug ON epics(slug);
CREATE INDEX idx_features_slug ON features(slug);
CREATE INDEX idx_tasks_slug ON tasks(slug);
```

### Implementation Details

**Lookup Strategy (Task Example):**
1. Try exact match on `key` column (handles legacy numeric keys)
2. If not found and key contains slug suffix:
   - Parse numeric key: `T-E07-F01-001` from `T-E07-F01-001-implement-jwt-token-validation`
   - Parse slug: `implement-jwt-token-validation`
   - Query: `WHERE key = ? AND slug = ?`
3. If slug doesn't match, return "not found" (prevents false matches)

**Slug Uniqueness:**
- Slugs are NOT required to be globally unique
- Lookup requires BOTH numeric key AND slug to match
- This prevents collisions between tasks with similar titles
- Example: Two tasks titled "Update README" will have different numeric keys but same slug

**Backward Compatibility:**
- Existing databases work without slugs (slug column is NULL)
- Migration command available to backfill slugs: `shark migrate slugs`
- All commands work with numeric keys even if slugs don't exist

### Slug Migration

For existing databases without slugs:

```bash
# Backfill slugs for all epics, features, and tasks
shark migrate slugs

# Verify slugs were generated
shark task list --json | jq '.[].slug'
```

## File System Sync

- Task files are markdown at `docs/plan/<epic>/<feature>/<task-key>.md`
- File sync is unidirectional: filesystem → database (with conflict resolution)
- Status is NEVER synced from files; it's database-only for audit trail
- Discovery scans filesystem for epic/feature hierarchy
